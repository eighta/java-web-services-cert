Types ofWeb Services
====================

On the conceptual level, a service is a software component provided through a
network-accessible endpoint. The service consumer and provider use messages to exchange
invocation request and response information in the form of self-containing documents that
make very few assumptions about the technological capabilities of the receiver.

On a technical level, web services can be implemented in various ways. The two types of web
services discussed in this section can be distinguished as "big" web services and "RESTful" web
services.

"Big" Web Services:::Simple Object Access Protocol (SOAP)

In Java EE 6, JAX-WS provides the functionality for "big" web services, which are described in
Chapter 19, "Building Web Services with JAX-WS." Big web services use XML messages that
follow the Simple Object Access Protocol (SOAP) standard, an XML language defining a
message architecture and message formats. Such systems often contain a machine-readable
description of the operations offered by the service, written in the Web ServicesDescription
Language (WSDL), an XML language for defining interfaces syntactically.

A SOAP-based design must include the following elements.

-A formal contract must be established to describe the interface that the web service offers.
WSDL can be used to describe the details of the contract, which may include messages,
operations, bindings, and the location of the web service. You may also process SOAP
messages in a JAX-WS service without publishing aWSDL.

-The architecture must address complex nonfunctional requirements.Many web service
specifications address such requirements and establish a common vocabulary for them.
Examples include transactions, security, addressing, trust, coordination, and so on.

-The architecture needs to handle asynchronous processing and invocation. In such cases,
the infrastructure provided by standards, such as Web Services ReliableMessaging
(WSRM), and APIs, such as JAX-WS, with their client-side asynchronous invocation
support, can be leveraged out of the box.


RESTfulWeb Services


In Java EE 6, JAX-RS provides the functionality for Representational State Transfer (RESTful)
web services. REST is well suited for basic, ad hoc integration scenarios. RESTful web services,
often better integrated with HTTP than SOAP-based services are, do not require XML messages
or WSDL service API definitions.

Project Jersey is the production-ready reference implementation for the JAX-RS specification.
Jersey implements support for the annotations defined in the JAX-RS specification, making it
easy for developers to build RESTful web services with Java and the Java VirtualMachine
(JVM).

A RESTful design may be appropriate when the following conditions are met.

-The web services are completely stateless. A good test is to consider whether the interaction
can survive a restart of the server.

-A caching infrastructure can be leveraged for performance. If the data that the web service
returns is not dynamically generated and can be cached, the caching infrastructure that web
servers and other intermediaries inherently provide can be leveraged to improve
performance.However, the developer must take care because such caches are limited to the
HTTP GET method for most servers.

-The service producer and service consumer have a mutual understanding of the context and
content being passed along. Because there is no formal way to describe the web services
interface, both parties must agree out of band on the schemas that describe the data being
exchanged and on ways to process it meaningfully. In the real world, most commercial
applications that expose services as RESTful implementations also distribute so-called
value-added toolkits that describe the interfaces to developers in popular programming
languages.

-Bandwidth is particularly important and needs to be limited. REST is particularly useful for
limited-profile devices, such as PDAs and mobile phones, for which the overhead of headers
and additional layers of SOAP elements on the XML payload must be restricted.

-Web service delivery or aggregation into existing web sites can be enabled easily with a
RESTful style.Developers can use such technologies as JAX-RS and Asynchronous
JavaScript with XML (AJAX) and such toolkits as Direct Web Remoting (DWR) to consume
the services in their web applications. Rather than starting from scratch, services can be
exposed with XML and consumed by HTML pages without significantly refactoring the
existing web site architecture. Existing developers will be more productive because they are
adding to something they are already familiar with rather than having to start from scratch
with new technology.


DecidingWhichType ofWeb Service to Use
======================================

Basically, you would want to use RESTful web services for integration over the web and use big
web services in enterprise application integration scenarios that have advanced quality of
service (QoS) requirements.

-JAX-WS: addresses advancedQoS requirements commonly occurring in enterprise
computing. When compared to JAX-RS, JAX-WS makes it easier to support the WS-* set of
protocols, which provide standards for security and reliability, among other things, and
interoperate with other WS-* conforming clients and servers.

-JAX-RS: makes it easier to write web applications that apply some or all of the constraints of
the REST style to induce desirable properties in the application, such as loose coupling
(evolving the server is easier without breaking existing clients), scalability (start small and
grow), and architectural simplicity (use off-the-shelf components, such as proxies or HTTP
routers). You would choose to use JAX-RS for your web application because it is easier for
many types of clients to consume RESTful web services while enabling the server side to
evolve and scale. Clients can choose to consume some or all aspects of the service and mash
it up with other web-based services.

BuildingWeb Services with JAX-WS
================================

Java API for XML Web Services (JAX-WS) is a technology for building web services and clients
that communicate using XML. JAX-WS allows developers to write message-oriented as well as
Remote Procedure Call-oriented (RPC-oriented) web services.

In JAX-WS, a web service operation invocation is represented by an XML-based protocol, such
as SOAP. The SOAP specification defines the envelope structure, encoding rules, and
conventions for representing web service invocations and responses. These calls and responses
are transmitted as SOAP messages (XML files) over HTTP.

Although SOAP messages are complex, the JAX-WS API hides this complexity from the
application developer. On the server side, the developer specifies the web service operations by
defining methods in an interface written in the Java programming language. The developer also
codes one or more classes that implement those methods. Client programs are also easy to code.
A client creates a proxy (a local object representing the service) and then simply invokes
methods on the proxy. With JAX-WS, the developer does not generate or parse SOAP messages.
It is the JAX-WS runtime system that converts the API calls and responses to and from SOAP
messages.

With JAX-WS, clients and web services have a big advantage: the platform independence of the
Java programming language. In addition, JAX-WS is not restrictive: A JAX-WS client can access
a web service that is not running on the Java platform, and vice versa. This flexibility is possible
because JAX-WS uses technologies defined by the W3C: HTTP, SOAP, andWSDL.WSDL
specifies an XML format for describing a service as a set of endpoints operating on messages.

Creating a SimpleWeb Service and Clients with JAX-WS
====================================================

The starting point for developing a JAX-WS web service is a Java class annotated with the
javax.jws.WebService annotation. The @WebService annotation defines the class as a web
service endpoint.

A service endpoint interface or service endpoint implementation (SEI) is a Java interface or class,
respectively, that declares the methods that a client can invoke on the service. An interface is not
required when building a JAX-WS endpoint. The web service implementation class implicitly
defines an SEI.

You may specify an explicit interface by adding the endpointInterface element to the
@WebService annotation in the implementation class. You must then provide an interface that
defines the public methods made available in the endpoint implementation class.

The basic steps for creating a web service and client are as follows:
1. Code the implementation class.

2. Compile the implementation class.

3. Package the files into aWARfile.

4. Deploy theWARfile. The web service artifacts, which are used to communicate with clients,
are generated by the GlassFish Server during deployment.

5. Code the client class.

6. Use a wsimport Ant task to generate and compile the web service artifacts needed to connect
to the service.

7. Compile the client class.

8. Run the client.

Requirements of a JAX-WS Endpoint
=================================

JAX-WS endpoints must follow these requirements.

-The implementing class must be annotated with either the javax.jws.WebService or the
javax.jws.WebServiceProvider annotation.

-The implementing class may explicitly reference an SEI through the endpointInterface
element of the @WebService annotation but is not required to do so. If no
endpointInterface is specified in @WebService, an SEI is implicitly defined for the
implementing class.

-The business methods of the implementing class must be public and must not be declared
static or final.

-Business methods that are exposed to web service clients must be annotated with
javax.jws.WebMethod.

-Business methods that are exposed to web service clients must have JAXB-compatible
parameters and return types.
>>>http://docs.oracle.com/javaee/5/tutorial/doc/bnazq.html#bnazs

-The implementing class must not be declared final and must not be abstract.

-The implementing class must have a default public constructor.

-The implementing class must not define the finalize method.

-The implementing class may use the javax.annotation.PostConstruct or the
javax.annotation.PreDestroy annotations on its methods for lifecycle event callbacks.

The @PostConstruct method is called by the container before the implementing class
begins responding to web service clients.

The @PreDestroy method is called by the container before the endpoint is removed from
operation.

>>>Coding the Service Endpoint Implementation Class
-@WebService
-@WebMethod

NOTA IMPORTANTE
===============
Cuando se crea un WebService de la forma anterior (con una clase)
Los end points quedan de la siguiente forma:

Service Name:	[class name] + "Service"
Port Name:		[class name] + "Port"

A Simple JAX-WS Application Client
==================================

The HelloAppClient class is a stand-alone application client that accesses the sayHello
method of HelloService. This call is made through a port, a local object that acts as a proxy for
the remote service. The port is created at development time by the wsimport task, which
generates JAX-WS portable artifacts based on a WSDL file.

the wsimport task
->appclient.jar
->webclient.war


Types Supported by JAX-WS
=========================

JAX-WS delegates the mapping of Java programming language types to and from XML
definitions to JAXB. Application developers don't need to know the details of these mappings
but should be aware that not every class in the Java language can be used as a method parameter
or return type in JAX-WS.

The following sections explain the default schema-to-Java and Java-to-schema data type
bindings.

Schema-to-Java Mapping
The Java language provides a richer set of data type than XML schema. the next Table lists the
mapping of XML data types to Java data types in JAXB.

XML SchemaType Java DataType
xsd:string java.lang.String
xsd:integer java.math.BigInteger
xsd:int int
xsd.long long
xsd:short short
xsd:decimal java.math.BigDecimal
xsd:float float
xsd:double double
xsd:boolean boolean
xsd:byte
MAS... PAGINA 377

Web Services Interoperability and JAX-WS
========================================

JAX-WS supports the Web Services Interoperability (WS-I) Basic Profile Version 1.1. The WS-I
Basic Profile is a document that clarifies the SOAP 1.1 andWSDL 1.1 specifications to promote
SOAP interoperability.

To support WS-I Basic Profile Version 1.1, the JAX-WS runtime supports doc/literal and
rpc/literal encodings for services, static ports, dynamic proxies, and theDynamic Invocation
Interface (DII).

Further Information about JAX-WS
For more information about JAX-WS and related technologies, see
 Java API for XML Web Services 2.2 specification:
http://jcp.org/aboutJava/communityprocess/mrel/jsr224/index4.html
 JAX-WS home:
http://jax-ws.java.net/
 Simple Object Access Protocol (SOAP) 1.2 W3CNote:
http://www.w3.org/TR/soap/
 Web ServicesDescription Language (WSDL) 1.1 W3CNote:
http://www.w3.org/TR/wsdl
 WS-I Basic Profile 1.1:
http://www.ws-i.org


RESTfulWeb Services with JAX-RS
===============================
This chapter describes the REST architecture, RESTful web services, and the Java API for
RESTful Web Services (JAX-RS, defined in JSR 311).

Jersey, the reference implementation of JAX-RS, implements support for the annotations
defined in JSR 311, making it easy for developers to build RESTful web services by using the Java
programming language.

What Are RESTfulWeb Services?

RESTful web services are built to work best on the Web. Representational State Transfer (REST)
is an architectural style that specifies constraints, such as the uniform interface, that if applied to
a web service induce desirable properties, such as performance, scalability, and modifiability,
that enable services to work best on the Web. In the REST architectural style, data and
functionality are considered resources and are accessed using Uniform Resource Identifiers
(URIs), typically links on the Web. The resources are acted upon by using a set of simple,
well-defined operations. The REST architectural style constrains an architecture to a
client/server architecture and is designed to use a stateless communication protocol, typically
HTTP. In the REST architecture style, clients and servers exchange representations of resources
by using a standardized interface and protocol.

The following principles encourage RESTful applications to be simple, lightweight, and fast:

 Resource identification through URI: A RESTful web service exposes a set of resources
that identify the targets of the interaction with its clients. Resources are identified by URIs,
which provide a global addressing space for resource and service discovery. See The "@Path
Annotation and URI Path Templates" on page 385 for more information.

 Uniform interface: Resources are manipulated using a fixed set of four create, read, update,
delete operations: PUT, GET, POST, and DELETE. PUT creates a new resource, which can be then
deleted by using DELETE. GET retrieves the current state of a resource in some representation.
POST transfers a new state onto a resource. See "Responding to HTTPMethods and
Requests" on page 387 for more information.

 Self-descriptive messages: Resources are decoupled from their representation so that their
content can be accessed in a variety of formats, such as HTML, XML, plain text, PDF, JPEG,
JSON, and others.Metadata about the resource is available and used, for example, to control
caching, detect transmission errors, negotiate the appropriate representation format, and
perform authentication or access control. See "Responding to HTTPMethods and
Requests" on page 387 and "Using Entity Providers toMap HTTP Response and Request
Entity Bodies" on page 389 for more information.

 Stateful interactions through hyperlinks: Every interaction with a resource is stateless; that
is, request messages are self-contained. Stateful interactions are based on the concept of
explicit state transfer. Several techniques exist to exchange state, such as URI rewriting,
cookies, and hidden form fields. State can be embedded in response messages to point to
valid future states of the interaction. See "Using Entity Providers toMap HTTP Response
and Request Entity Bodies" on page 389 and "Building URIs" in the JAX-RSOverview
document for more information.

Creating a RESTful Root Resource Class
======================================

Root resource classes are POJOs that are either annotated with @Path or have at least one method
annotated with @Path or a request method designator, such as @GET, @PUT, @POST, or @DELETE.
Resource methods are methods of a resource class annotated with a request method designator.

Developing RESTful Web Services with JAX-RS
-------------------------------------------
JAX-RS is a Java programming language API designed to make it easy to develop applications
that use the REST architecture.

The JAX-RS API uses Java programming language annotations to simplify the development of
RESTful web services. Developers decorate Java programming language class files with JAX-RS
annotations to define resources and the actions that can be performed on those resources.
JAX-RS annotations are runtime annotations; therefore, runtime reflection will generate the
helper classes and artifacts for the resource. A Java EE application archive containing JAX-RS
resource classes will have the resources configured, the helper classes and artifacts generated,
and the resource exposed to clients by deploying the archive to a Java EE server.

Next, lists some of the Java programming annotations that are defined by JAX-RS, with a
brief description of how each is used. Further information on the JAX-RS APIs can be viewed at
http://docs.oracle.com/javaee/6/api/.


Annotation Description

@Path 
The @Path annotation’s value is a relative URI path indicating where the Java class will
be hosted: for example, /helloworld. You can also embed variables in the URIs to
make a URI path template. For example, you could ask for the name of a user and pass
it to the application as a variable in the URI: /helloworld/{username}.

@GET 
The @GET annotation is a request method designator and corresponds to the similarly
named HTTP method. The Java method annotated with this request method
designator will process HTTP GET requests. The behavior of a resource is determined
by the HTTP method to which the resource is responding.

@POST 
The @POST annotation is a request method designator and corresponds to the similarly
named HTTP method. The Java method annotated with this request method
designator will process HTTP POST requests. The behavior of a resource is
determined by the HTTP method to which the resource is responding.

@PUT 
The @PUT annotation is a request method designator and corresponds to the similarly
named HTTP method. The Java method annotated with this request method
designator will process HTTP PUT requests. The behavior of a resource is determined
by the HTTP method to which the resource is responding.

@DELETE 
The @DELETE annotation is a request method designator and corresponds to the
similarly named HTTP method. The Java method annotated with this request method
designator will process HTTP DELETE requests. The behavior of a resource is
determined by the HTTP method to which the resource is responding.

@HEAD 
The @HEAD annotation is a request method designator and corresponds to the similarly
named HTTP method. The Java method annotated with this request method
designator will process HTTP HEAD requests. The behavior of a resource is
determined by the HTTP method to which the resource is responding.

@PathParam 
The @PathParam annotation is a type of parameter that you can extract for use in your
resource class. URI path parameters are extracted from the request URI, and the
parameter names correspond to the URI path template variable names specified in the
@Path class-level annotation.

@QueryParam 
The @QueryParam annotation is a type of parameter that you can extract for use in your
resource class. Query parameters are extracted from the request URI query parameters.

@Consumes 
The @Consumes annotation is used to specify the MIME media types of representations
a resource can consume that were sent by the client.

@Produces 
The @Produces annotation is used to specify the MIME media types of representations
a resource can produce and send back to the client: for example, "text/plain".

@Provider 
The @Provider annotation is used for anything that is of interest to the JAX-RS
runtime, such as MessageBodyReader and MessageBodyWriter. For HTTP requests,
the MessageBodyReader is used to map an HTTP request entity body to method
parameters. On the response side, a return value is mapped to an HTTP response entity
body by using a MessageBodyWriter. If the application needs to supply additional
metadata, such as HTTP headers or a different status code, a method can return a
Response that wraps the entity and that can be built using
Response.ResponseBuilder.


The @Path Annotation and URI Path Templates
===========================================

The @Path annotation identifies the URI path template to which the resource responds and is
specified at the class or method level of a resource. The @Path annotation’s value is a partial URI
path template relative to the base URI of the server on which the resource is deployed, the
context root of the application, and the URL pattern to which the JAX-RS runtime responds.

URI path templates are URIs with variables embedded within the URI syntax. These variables
are substituted at runtime in order for a resource to respond to a request based on the
substituted URI. Variables are denoted by braces ({ and }). For example, look at the following
@Path annotation:
@Path("/users/{username}")

In this kind of example, a user is prompted to type his or her name, and then a JAX-RS web
service configured to respond to requests to this URI path template responds. For example, if
the user types the user name “Galileo,” the web service responds to the following URL:
http://example.com/users/Galileo

To obtain the value of the user name, the @PathParam annotation may be used on the method
parameter of a request method, as shown in the following code example:

@Path("/users/{username}")
public class UserResource {
	@GET
	@Produces("text/xml")
	public String getUser(@PathParam("username") String userName) {
		...
	}
}

By default, the URI variable must match the regular expression "[^/]+?". This variable may be
customized by specifying a different regular expression after the variable name. For example, if
a user name must consist only of lowercase and uppercase alphanumeric characters, override
the default regular expression in the variable definition:
@Path("users/{username: [a-zA-Z][a-zA-Z_0-9]*}")

In this example the username variable will match only user names that begin with one
uppercase or lowercase letter and zero or more alphanumeric characters and the underscore
character. If a user name does not match that template, a 404 (Not Found) response will be sent
to the client.















page 382


//guias de primera implemenetacion

https://www.mkyong.com/webservices/jax-ws/deploy-jax-ws-web-services-on-tomcat/
https://examples.javacodegeeks.com/enterprise-java/jws/jax-ws-web-services-on-tomcat/
https://www.javacodegeeks.com/2012/03/web-services-with-jax-ws-on-tomcat.html
https://jaxenter.com/creating-soap-web-services-using-jax-ws-117689.html
http://stackoverflow.com/questions/12581751/sun-jaxws-xml-when-is-it-needed-and-when-not
http://docs.oracle.com/cd/E17802_01/webservices/webservices/docs/2.0/jaxws/jaxws-war.html
http://ics.upjs.sk/~novotnyr/blog/2068/deploying-jax-ws-services-on-java-7-and-tomcat-7











