Types ofWeb Services
====================

On the conceptual level, a service is a software component provided through a
network-accessible endpoint. The service consumer and provider use messages to exchange
invocation request and response information in the form of self-containing documents that
make very few assumptions about the technological capabilities of the receiver.

On a technical level, web services can be implemented in various ways. The two types of web
services discussed in this section can be distinguished as "big" web services and "RESTful" web
services.

"Big" Web Services:::Simple Object Access Protocol (SOAP)

In Java EE 6, JAX-WS provides the functionality for "big" web services, which are described in
Chapter 19, "Building Web Services with JAX-WS." Big web services use XML messages that
follow the Simple Object Access Protocol (SOAP) standard, an XML language defining a
message architecture and message formats. Such systems often contain a machine-readable
description of the operations offered by the service, written in the Web ServicesDescription
Language (WSDL), an XML language for defining interfaces syntactically.

A SOAP-based design must include the following elements.

-A formal contract must be established to describe the interface that the web service offers.
WSDL can be used to describe the details of the contract, which may include messages,
operations, bindings, and the location of the web service. You may also process SOAP
messages in a JAX-WS service without publishing aWSDL.

-The architecture must address complex nonfunctional requirements.Many web service
specifications address such requirements and establish a common vocabulary for them.
Examples include transactions, security, addressing, trust, coordination, and so on.

-The architecture needs to handle asynchronous processing and invocation. In such cases,
the infrastructure provided by standards, such as Web Services ReliableMessaging
(WSRM), and APIs, such as JAX-WS, with their client-side asynchronous invocation
support, can be leveraged out of the box.


RESTfulWeb Services


In Java EE 6, JAX-RS provides the functionality for Representational State Transfer (RESTful)
web services. REST is well suited for basic, ad hoc integration scenarios. RESTful web services,
often better integrated with HTTP than SOAP-based services are, do not require XML messages
or WSDL service API definitions.

Project Jersey is the production-ready reference implementation for the JAX-RS specification.
Jersey implements support for the annotations defined in the JAX-RS specification, making it
easy for developers to build RESTful web services with Java and the Java VirtualMachine
(JVM).

A RESTful design may be appropriate when the following conditions are met.

-The web services are completely stateless. A good test is to consider whether the interaction
can survive a restart of the server.

-A caching infrastructure can be leveraged for performance. If the data that the web service
returns is not dynamically generated and can be cached, the caching infrastructure that web
servers and other intermediaries inherently provide can be leveraged to improve
performance.However, the developer must take care because such caches are limited to the
HTTP GET method for most servers.

-The service producer and service consumer have a mutual understanding of the context and
content being passed along. Because there is no formal way to describe the web services
interface, both parties must agree out of band on the schemas that describe the data being
exchanged and on ways to process it meaningfully. In the real world, most commercial
applications that expose services as RESTful implementations also distribute so-called
value-added toolkits that describe the interfaces to developers in popular programming
languages.

-Bandwidth is particularly important and needs to be limited. REST is particularly useful for
limited-profile devices, such as PDAs and mobile phones, for which the overhead of headers
and additional layers of SOAP elements on the XML payload must be restricted.

-Web service delivery or aggregation into existing web sites can be enabled easily with a
RESTful style.Developers can use such technologies as JAX-RS and Asynchronous
JavaScript with XML (AJAX) and such toolkits as Direct Web Remoting (DWR) to consume
the services in their web applications. Rather than starting from scratch, services can be
exposed with XML and consumed by HTML pages without significantly refactoring the
existing web site architecture. Existing developers will be more productive because they are
adding to something they are already familiar with rather than having to start from scratch
with new technology.


DecidingWhichType ofWeb Service to Use
======================================

Basically, you would want to use RESTful web services for integration over the web and use big
web services in enterprise application integration scenarios that have advanced quality of
service (QoS) requirements.

-JAX-WS: addresses advancedQoS requirements commonly occurring in enterprise
computing. When compared to JAX-RS, JAX-WS makes it easier to support the WS-* set of
protocols, which provide standards for security and reliability, among other things, and
interoperate with other WS-* conforming clients and servers.

-JAX-RS: makes it easier to write web applications that apply some or all of the constraints of
the REST style to induce desirable properties in the application, such as loose coupling
(evolving the server is easier without breaking existing clients), scalability (start small and
grow), and architectural simplicity (use off-the-shelf components, such as proxies or HTTP
routers). You would choose to use JAX-RS for your web application because it is easier for
many types of clients to consume RESTful web services while enabling the server side to
evolve and scale. Clients can choose to consume some or all aspects of the service and mash
it up with other web-based services.

BuildingWeb Services with JAX-WS
================================

Java API for XML Web Services (JAX-WS) is a technology for building web services and clients
that communicate using XML. JAX-WS allows developers to write message-oriented as well as
Remote Procedure Call-oriented (RPC-oriented) web services.

In JAX-WS, a web service operation invocation is represented by an XML-based protocol, such
as SOAP. The SOAP specification defines the envelope structure, encoding rules, and
conventions for representing web service invocations and responses. These calls and responses
are transmitted as SOAP messages (XML files) over HTTP.

Although SOAP messages are complex, the JAX-WS API hides this complexity from the
application developer. On the server side, the developer specifies the web service operations by
defining methods in an interface written in the Java programming language. The developer also
codes one or more classes that implement those methods. Client programs are also easy to code.
A client creates a proxy (a local object representing the service) and then simply invokes
methods on the proxy. With JAX-WS, the developer does not generate or parse SOAP messages.
It is the JAX-WS runtime system that converts the API calls and responses to and from SOAP
messages.

With JAX-WS, clients and web services have a big advantage: the platform independence of the
Java programming language. In addition, JAX-WS is not restrictive: A JAX-WS client can access
a web service that is not running on the Java platform, and vice versa. This flexibility is possible
because JAX-WS uses technologies defined by the W3C: HTTP, SOAP, andWSDL.WSDL
specifies an XML format for describing a service as a set of endpoints operating on messages.

Creating a SimpleWeb Service and Clients with JAX-WS
====================================================

The starting point for developing a JAX-WS web service is a Java class annotated with the
javax.jws.WebService annotation. The @WebService annotation defines the class as a web
service endpoint.

A service endpoint interface or service endpoint implementation (SEI) is a Java interface or class,
respectively, that declares the methods that a client can invoke on the service. An interface is not
required when building a JAX-WS endpoint. The web service implementation class implicitly
defines an SEI.

You may specify an explicit interface by adding the endpointInterface element to the
@WebService annotation in the implementation class. You must then provide an interface that
defines the public methods made available in the endpoint implementation class.

The basic steps for creating a web service and client are as follows:
1. Code the implementation class.

2. Compile the implementation class.

3. Package the files into aWARfile.

4. Deploy theWARfile. The web service artifacts, which are used to communicate with clients,
are generated by the GlassFish Server during deployment.

5. Code the client class.

6. Use a wsimport Ant task to generate and compile the web service artifacts needed to connect
to the service.

7. Compile the client class.

8. Run the client.

Requirements of a JAX-WS Endpoint
=================================

JAX-WS endpoints must follow these requirements.

-The implementing class must be annotated with either the javax.jws.WebService or the
javax.jws.WebServiceProvider annotation.

-The implementing class may explicitly reference an SEI through the endpointInterface
element of the @WebService annotation but is not required to do so. If no
endpointInterface is specified in @WebService, an SEI is implicitly defined for the
implementing class.

-The business methods of the implementing class must be public and must not be declared
static or final.

-Business methods that are exposed to web service clients must be annotated with
javax.jws.WebMethod.

-Business methods that are exposed to web service clients must have JAXB-compatible
parameters and return types.
>>>http://docs.oracle.com/javaee/5/tutorial/doc/bnazq.html#bnazs

-The implementing class must not be declared final and must not be abstract.

-The implementing class must have a default public constructor.

-The implementing class must not define the finalize method.

-The implementing class may use the javax.annotation.PostConstruct or the
javax.annotation.PreDestroy annotations on its methods for lifecycle event callbacks.

The @PostConstruct method is called by the container before the implementing class
begins responding to web service clients.

The @PreDestroy method is called by the container before the endpoint is removed from
operation.

>>>Coding the Service Endpoint Implementation Class
-@WebService
-@WebMethod

NOTA IMPORTANTE
===============
Cuando se crea un WebService de la forma anterior (con una clase)
Los end points quedan de la siguiente forma:

Service Name:	[class name] + "Service"
Port Name:		[class name] + "Port"

A Simple JAX-WS Application Client
==================================

The HelloAppClient class is a stand-alone application client that accesses the sayHello
method of HelloService. This call is made through a port, a local object that acts as a proxy for
the remote service. The port is created at development time by the wsimport task, which
generates JAX-WS portable artifacts based on a WSDL file.

the wsimport task
->appclient.jar
->webclient.war


Types Supported by JAX-WS
=========================

JAX-WS delegates the mapping of Java programming language types to and from XML
definitions to JAXB. Application developers don't need to know the details of these mappings
but should be aware that not every class in the Java language can be used as a method parameter
or return type in JAX-WS.

The following sections explain the default schema-to-Java and Java-to-schema data type
bindings.

Schema-to-Java Mapping
The Java language provides a richer set of data type than XML schema. the next Table lists the
mapping of XML data types to Java data types in JAXB.

XML SchemaType Java DataType
xsd:string java.lang.String
xsd:integer java.math.BigInteger
xsd:int int
xsd.long long
xsd:short short
xsd:decimal java.math.BigDecimal
xsd:float float
xsd:double double
xsd:boolean boolean
xsd:byte
MAS... PAGINA 377

Web Services Interoperability and JAX-WS
========================================

JAX-WS supports the Web Services Interoperability (WS-I) Basic Profile Version 1.1. The WS-I
Basic Profile is a document that clarifies the SOAP 1.1 andWSDL 1.1 specifications to promote
SOAP interoperability.

To support WS-I Basic Profile Version 1.1, the JAX-WS runtime supports doc/literal and
rpc/literal encodings for services, static ports, dynamic proxies, and theDynamic Invocation
Interface (DII).

Further Information about JAX-WS
For more information about JAX-WS and related technologies, see
 Java API for XML Web Services 2.2 specification:
http://jcp.org/aboutJava/communityprocess/mrel/jsr224/index4.html
 JAX-WS home:
http://jax-ws.java.net/
 Simple Object Access Protocol (SOAP) 1.2 W3CNote:
http://www.w3.org/TR/soap/
 Web ServicesDescription Language (WSDL) 1.1 W3CNote:
http://www.w3.org/TR/wsdl
 WS-I Basic Profile 1.1:
http://www.ws-i.org


RESTfulWeb Services with JAX-RS
===============================
This chapter describes the REST architecture, RESTful web services, and the Java API for
RESTful Web Services (JAX-RS, defined in JSR 311).

Jersey, the reference implementation of JAX-RS, implements support for the annotations
defined in JSR 311, making it easy for developers to build RESTful web services by using the Java
programming language.

What Are RESTfulWeb Services?

RESTful web services are built to work best on the Web. Representational State Transfer (REST)
is an architectural style that specifies constraints, such as the uniform interface, that if applied to
a web service induce desirable properties, such as performance, scalability, and modifiability,
that enable services to work best on the Web. In the REST architectural style, data and
functionality are considered resources and are accessed using Uniform Resource Identifiers
(URIs), typically links on the Web. The resources are acted upon by using a set of simple,
well-defined operations. The REST architectural style constrains an architecture to a
client/server architecture and is designed to use a stateless communication protocol, typically
HTTP. In the REST architecture style, clients and servers exchange representations of resources
by using a standardized interface and protocol.

The following principles encourage RESTful applications to be simple, lightweight, and fast:

 Resource identification through URI: A RESTful web service exposes a set of resources
that identify the targets of the interaction with its clients. Resources are identified by URIs,
which provide a global addressing space for resource and service discovery. See The "@Path
Annotation and URI Path Templates" on page 385 for more information.

 Uniform interface: Resources are manipulated using a fixed set of four create, read, update,
delete operations: PUT, GET, POST, and DELETE. PUT creates a new resource, which can be then
deleted by using DELETE. GET retrieves the current state of a resource in some representation.
POST transfers a new state onto a resource. See "Responding to HTTPMethods and
Requests" on page 387 for more information.

 Self-descriptive messages: Resources are decoupled from their representation so that their
content can be accessed in a variety of formats, such as HTML, XML, plain text, PDF, JPEG,
JSON, and others.Metadata about the resource is available and used, for example, to control
caching, detect transmission errors, negotiate the appropriate representation format, and
perform authentication or access control. See "Responding to HTTPMethods and
Requests" on page 387 and "Using Entity Providers toMap HTTP Response and Request
Entity Bodies" on page 389 for more information.

 Stateful interactions through hyperlinks: Every interaction with a resource is stateless; that
is, request messages are self-contained. Stateful interactions are based on the concept of
explicit state transfer. Several techniques exist to exchange state, such as URI rewriting,
cookies, and hidden form fields. State can be embedded in response messages to point to
valid future states of the interaction. See "Using Entity Providers toMap HTTP Response
and Request Entity Bodies" on page 389 and "Building URIs" in the JAX-RSOverview
document for more information.

Creating a RESTful Root Resource Class
======================================

Root resource classes are POJOs that are either annotated with @Path or have at least one method
annotated with @Path or a request method designator, such as @GET, @PUT, @POST, or @DELETE.
Resource methods are methods of a resource class annotated with a request method designator.

Developing RESTful Web Services with JAX-RS
-------------------------------------------
JAX-RS is a Java programming language API designed to make it easy to develop applications
that use the REST architecture.

The JAX-RS API uses Java programming language annotations to simplify the development of
RESTful web services. Developers decorate Java programming language class files with JAX-RS
annotations to define resources and the actions that can be performed on those resources.
JAX-RS annotations are runtime annotations; therefore, runtime reflection will generate the
helper classes and artifacts for the resource. A Java EE application archive containing JAX-RS
resource classes will have the resources configured, the helper classes and artifacts generated,
and the resource exposed to clients by deploying the archive to a Java EE server.

Next, lists some of the Java programming annotations that are defined by JAX-RS, with a
brief description of how each is used. Further information on the JAX-RS APIs can be viewed at
http://docs.oracle.com/javaee/6/api/.


Annotation Description

@Path 
The @Path annotation’s value is a relative URI path indicating where the Java class will
be hosted: for example, /helloworld. You can also embed variables in the URIs to
make a URI path template. For example, you could ask for the name of a user and pass
it to the application as a variable in the URI: /helloworld/{username}.

@GET 
The @GET annotation is a request method designator and corresponds to the similarly
named HTTP method. The Java method annotated with this request method
designator will process HTTP GET requests. The behavior of a resource is determined
by the HTTP method to which the resource is responding.

@POST 
The @POST annotation is a request method designator and corresponds to the similarly
named HTTP method. The Java method annotated with this request method
designator will process HTTP POST requests. The behavior of a resource is
determined by the HTTP method to which the resource is responding.

@PUT 
The @PUT annotation is a request method designator and corresponds to the similarly
named HTTP method. The Java method annotated with this request method
designator will process HTTP PUT requests. The behavior of a resource is determined
by the HTTP method to which the resource is responding.

@DELETE 
The @DELETE annotation is a request method designator and corresponds to the
similarly named HTTP method. The Java method annotated with this request method
designator will process HTTP DELETE requests. The behavior of a resource is
determined by the HTTP method to which the resource is responding.

@HEAD 
The @HEAD annotation is a request method designator and corresponds to the similarly
named HTTP method. The Java method annotated with this request method
designator will process HTTP HEAD requests. The behavior of a resource is
determined by the HTTP method to which the resource is responding.

@PathParam 
The @PathParam annotation is a type of parameter that you can extract for use in your
resource class. URI path parameters are extracted from the request URI, and the
parameter names correspond to the URI path template variable names specified in the
@Path class-level annotation.

@QueryParam 
The @QueryParam annotation is a type of parameter that you can extract for use in your
resource class. Query parameters are extracted from the request URI query parameters.

@Consumes 
The @Consumes annotation is used to specify the MIME media types of representations
a resource can consume that were sent by the client.

@Produces 
The @Produces annotation is used to specify the MIME media types of representations
a resource can produce and send back to the client: for example, "text/plain".

@Provider 
The @Provider annotation is used for anything that is of interest to the JAX-RS
runtime, such as MessageBodyReader and MessageBodyWriter. For HTTP requests,
the MessageBodyReader is used to map an HTTP request entity body to method
parameters. On the response side, a return value is mapped to an HTTP response entity
body by using a MessageBodyWriter. If the application needs to supply additional
metadata, such as HTTP headers or a different status code, a method can return a
Response that wraps the entity and that can be built using
Response.ResponseBuilder.


The @Path Annotation and URI Path Templates
===========================================

The @Path annotation identifies the URI path template to which the resource responds and is
specified at the class or method level of a resource. The @Path annotation’s value is a partial URI
path template relative to the base URI of the server on which the resource is deployed, the
context root of the application, and the URL pattern to which the JAX-RS runtime responds.

URI path templates are URIs with variables embedded within the URI syntax. These variables
are substituted at runtime in order for a resource to respond to a request based on the
substituted URI. Variables are denoted by braces ({ and }). For example, look at the following
@Path annotation:
@Path("/users/{username}")

In this kind of example, a user is prompted to type his or her name, and then a JAX-RS web
service configured to respond to requests to this URI path template responds. For example, if
the user types the user name “Galileo,” the web service responds to the following URL:
http://example.com/users/Galileo

To obtain the value of the user name, the @PathParam annotation may be used on the method
parameter of a request method, as shown in the following code example:

@Path("/users/{username}")
public class UserResource {
	@GET
	@Produces("text/xml")
	public String getUser(@PathParam("username") String userName) {
		...
	}
}

By default, the URI variable must match the regular expression "[^/]+?". This variable may be
customized by specifying a different regular expression after the variable name. For example, if
a user name must consist only of lowercase and uppercase alphanumeric characters, override
the default regular expression in the variable definition:
@Path("users/{username: [a-zA-Z][a-zA-Z_0-9]*}")

In this example the username variable will match only user names that begin with one
uppercase or lowercase letter and zero or more alphanumeric characters and the underscore
character. If a user name does not match that template, a 404 (Not Found) response will be sent
to the client.

A @Path value isn’t required to have leading or trailing slashes (/). The JAX-RS runtime parses
URI path templates the same whether or not they have leading or trailing spaces

A URI path template has one or more variables, with each variable name surrounded by braces:
{ to begin the variable name and } to end it. In the preceding example, username is the variable
name. At runtime, a resource configured to respond to the preceding URI path template will
attempt to process the URI data that corresponds to the location of {username} in the URI as
the variable data for username.

Responding to HTTP Methods and Requests
---------------------------------------
The behavior of a resource is determined by the HTTP methods (typically, GET, POST, PUT,
DELETE) to which the resource is responding.

The Request Method Designator Annotations

Request method designator annotations are runtime annotations, defined by JAX-RS, that
correspond to the similarly named HTTP methods. Within a resource class file, HTTP methods
are mapped to Java programming language methods by using the request method designator
annotations. The behavior of a resource is determined by which HTTP method the resource is
responding to. JAX-RS defines a set of request method designators for the common HTTP
methods @GET, @POST, @PUT, @DELETE, and @HEAD; you can also create your own custom request
method designators. Creating custom request method designators is outside the scope of this
document.

By default, the JAX-RS runtime will automatically support the methods HEAD and OPTIONS if not
explicitly implemented. For HEAD, the runtime will invoke the implemented GET method, if
present, and ignore the response entity, if set. For OPTIONS, the Allow response header will be
set to the set of HTTP methods supported by the resource. In addition, the JAX-RS runtime will
return a Web Application Definition Language (WADL) document describing the resource; see
http://www.w3.org/Submission/wadl/ for more information.

Methods decorated with request method designators must return void, a Java programming
language type, or a javax.ws.rs.core.Response object. Multiple parameters may be extracted
from the URI by using the @PathParam or @QueryParam annotations as described in “Extracting
Request Parameters” on page 392. Conversion between Java types and an entity body is the
responsibility of an entity provider, such as MessageBodyReader or MessageBodyWriter.
Methods that need to provide additional metadata with a response should return an instance of
the Response class. The ResponseBuilder class provides a convenient way to create a Response
instance using a builder pattern. The HTTP PUT and POST methods expect an HTTP request
body, so you should use a MessageBodyReader for methods that respond to PUT and POST
requests.

Both @PUT and @POST can be used to create or update a resource. POST can mean anything, so
when using POST, it is up to the application to define the semantics. PUT has well-defined
semantics. When using PUT for creation, the client declares the URI for the newly created
resource.

PUT has very clear semantics for creating and updating a resource. The representation the client
sends must be the same representation that is received using a GET, given the same media type.
PUT does not allow a resource to be partially updated, a common mistake when attempting to
use the PUT method. A common application pattern is to use POST to create a resource and
return a 201 response with a location header whose value is the URI to the newly created
resource. In this pattern, the web service declares the URI for the newly created resource.

Using Entity Providers to Map HTTP Response and Request Entity Bodies
---------------------------------------------------------------------

Entity providers supply mapping services between representations and their associated Java
types. The two types of entity providers are MessageBodyReader and MessageBodyWriter. For
HTTP requests, the MessageBodyReader is used to map an HTTP request entity body to
method parameters. On the response side, a return value is mapped to an HTTP response entity
body by using a MessageBodyWriter. If the application needs to supply additional metadata,
such as HTTP headers or a different status code, a method can return a Response that wraps the
entity and that can be built by using Response.ResponseBuilder.

Next table shows the standard types that are supported automatically for HTTP request and
response entity bodies. You need to write an entity provider only if you are not choosing one of
these standard types.

Java Type Supported Media Types
byte[] All media types (*/*)
java.lang.String All text media types (text/*)
java.io.InputStream All media types (*/*)
java.io.Reader All media types (*/*)
java.io.File All media types (*/*)
javax.activation.DataSource All media types (*/*)
javax.xml.transform.Source XML media types (text/xml, application/xml, and
application/*+xml)
javax.xml.bind.JAXBElement and
application-supplied JAXB classes XML media types (text/xml, application/xml, and
application/*+xml)
MultivaluedMap<String, String> Form content
(application/x-www-form-urlencoded)
StreamingOutput All media types (*/*), MessageBodyWriter only


Using @Consumes and @Produces to Customize Requests and Responses
-----------------------------------------------------------------

The information sent to a resource and then passed back to the client is specified as a MIME
media type in the headers of an HTTP request or response. You can specify which MIME media
types of representations a resource can respond to or produce by using the following
annotations:
-javax.ws.rs.Consumes
-javax.ws.rs.Produces

By default, a resource class can respond to and produce all MIME media types of
representations specified in the HTTP request and response headers.

The @Produces Annotation
------------------------
The @Produces annotation is used to specify the MIME media types or representations a
resource can produce and send back to the client. If @Produces is applied at the class level, all
the methods in a resource can produce the specified MIME types by default. If applied at the
method level, the annotation overrides any @Produces annotations applied at the class level.

If no methods in a resource are able to produce the MIME type in a client request, the JAX-RS
runtime sends back an HTTP “406 Not Acceptable” error.

The value of @Produces is an array of String of MIME types. For example:
@Produces({"image/jpeg,image/png"})


If a resource class is capable of producing more than one MIME media type, the resource
method chosen will correspond to the most acceptable media type as declared by the client.
More specifically, the Accept header of the HTTP request declares what is most acceptable. For
example, if the Accept header is Accept: text/plain, the doGetAsPlainText method will be
invoked. Alternatively, if the Accept header is Accept: text/plain;q=0.9, text/html, which
declares that the client can accept media types of text/plain and text/html but prefers the
latter, the doGetAsHtml method will be invoked.

More than one media type may be declared in the same @Produces declaration. The following
code example shows how this is done:

@Produces({"application/xml", "application/json"})
public String doGetAsXmlOrJson() {
	...
}

The doGetAsXmlOrJson method will get invoked if either of the media types application/xml
and application/json is acceptable. If both are equally acceptable, the former will be chosen
because it occurs first. The preceding examples refer explicitly to MIME media types for clarity.
It is possible to refer to constant values, which may reduce typographical errors. For more
information, see the constant field values of MediaType at http://jsr311.java.net/nonav/
releases/1.0/javax/ws/rs/core/MediaType.html.

The @Consumes Annotation
------------------------
The @Consumes annotation is used to specify which MIME media types of representations a
resource can accept, or consume, from the client. If @Consumes is applied at the class level, all the
response methods accept the specified MIME types by default. If applied at the method level,
@Consumes overrides any @Consumes annotations applied at the class level.

If a resource is unable to consume the MIME type of a client request, the JAX-RS runtime sends
back an HTTP 415 (“Unsupported Media Type”) error.

The value of @Consumes is an array of String of acceptable MIME types. For example:
@Consumes({"text/plain,text/html"})

@Path("/myResource")
@Consumes("multipart/related")
public class SomeResource {
	@POST
	public String doPost(MimeMultipart mimeMultipartData) {
		...
	}
	
	@POST
	@Consumes("application/x-www-form-urlencoded")
	public String doPost2(FormURLEncodedProperties formData) {
		...
	}
}

The doPost method defaults to the MIME media type of the @Consumes annotation at the class
level. The doPost2 method overrides the class level @Consumes annotation to specify that it can
accept URL-encoded form data.

If no resource methods can respond to the requested MIME type, an HTTP 415 (“Unsupported
Media Type”) error is returned to the client.

The HelloWorld example discussed previously in this section can be modified to set the
message by using @Consumes, as shown in the following code example:

@POST
@Consumes("text/plain")
public void postClichedMessage(String message) {
	// Store the message
}
In this example, the Java method will consume representations identified by the MIME media
type text/plain. Note that the resource method returns void. This means that no
representation is returned and that a response with a status code of HTTP 204 (“No Content”)
will be returned.

Extracting Request Parameters
-----------------------------

Parameters of a resource method may be annotated with parameter-based annotations to
extract information from a request. A previous example presented the use of the @PathParam
parameter to extract a path parameter from the path component of the request URL that
matched the path declared in @Path.

You can extract the following types of parameters for use in your resource class:
-Query
-URI path
-Form
-Cookie
-Header
-Matrix

Query parameters are extracted from the request URI query parameters and are specified by
using the javax.ws.rs.QueryParam annotation in the method parameter arguments. The
following example, from the sparklines sample application, demonstrates using @QueryParam
to extract query parameters from the Query component of the request URL:

@Path("smooth")
@GET
public Response smooth(
	@DefaultValue("2") @QueryParam("step") int step,
	@DefaultValue("true") @QueryParam("min-m") boolean hasMin,
	@DefaultValue("true") @QueryParam("max-m") boolean hasMax,
	@DefaultValue("true") @QueryParam("last-m") boolean hasLast,
	@DefaultValue("blue") @QueryParam("min-color") ColorParam minColor,
	@DefaultValue("green") @QueryParam("max-color") ColorParam maxColor,
	@DefaultValue("red") @QueryParam("last-color") ColorParam lastColor
) { ... }


If the query parameter step exists in the query component of the request URI, the value of step
will be extracted and parsed as a 32-bit signed integer and assigned to the step method
parameter. If step does not exist, a default value of 2, as declared in the @DefaultValue
annotation, will be assigned to the step method parameter. If the step value cannot be parsed
as a 32-bit signed integer, an HTTP 400 (“Client Error”) response is returned.

Both @QueryParam and @PathParam can be used only on the following Java types:

- All primitive types except char
- All wrapper classes of primitive types except Character
- Any class with a constructor that accepts a single String argument
- Any class with the static method named valueOf(String) that accepts a single String
argument
- List<T>, Set<T>, or SortedSet<T>, where T matches the already listed criteria. Sometimes,
parameters may contain more than one value for the same name. If this is the case, these
types may be used to obtain all values

If @DefaultValue is not used in conjunction with @QueryParam, and the query parameter is not
present in the request, the value will be an empty collection for List, Set, or SortedSet; null for
other object types; and the default for primitive types.

URI path parameters
-------------------
URI path parameters are extracted from the request URI, and the parameter names correspond
to the URI path template variable names specified in the @Path class-level annotation. URI
parameters are specified using the javax.ws.rs.PathParam annotation in the method
parameter arguments. The following example shows how to use @Path variables and the
@PathParam annotation in a method:

@Path("/{username}")
public class MyResourceBean {
	...
	@GET
	public String printUsername(@PathParam("username") String userId) {
		...
	}
}

In the preceding snippet, the URI path template variable name username is specified as a
parameter to the printUsername method. The @PathParam annotation is set to the variable
name username. At runtime, before printUsername is called, the value of username is extracted
from the URI and cast to a String. The resulting String is then available to the method as the
userId variable.

If the URI path template variable cannot be cast to the specified type, the JAX-RS runtime
returns an HTTP 400 (“Bad Request”) error to the client. If the @PathParam annotation cannot
be cast to the specified type, the JAX-RS runtime returns an HTTP 404 (“Not Found”) error to
the client.

The @PathParam parameter and the other parameter-based annotations (@MatrixParam,
@HeaderParam, @CookieParam, and @FormParam) obey the same rules as @QueryParam.

Other's parameters
-----------------
Cookie parameters, indicated by decorating the parameter with javax.ws.rs.CookieParam,
extract information from the cookies declared in cookie-related HTTP headers. Header
parameters, indicated by decorating the parameter with javax.ws.rs.HeaderParam, extract
information from the HTTP headers. Matrix parameters, indicated by decorating the parameter
with javax.ws.rs.MatrixParam, extract information from URL path segments.

Form parameters, indicated by decorating the parameter with javax.ws.rs.FormParam, extract
information from a request representation that is of the MIME media type
application/x-www-form-urlencoded and conforms to the encoding specified by HTML
forms, as described in http://www.w3.org/TR/html401/interact/
forms.html#h-17.13.4.1. This parameter is very useful for extracting information sent by
POST in HTML forms.

The following example extracts the name form parameter from the POST form data:
@POST
@Consumes("application/x-www-form-urlencoded")
public void post(@FormParam("name") String name) {
	// Store the message
}


To obtain a general map of parameter names and values for query and path parameters, use the
following code:
@GET
public String get(@Context UriInfo ui) {
	MultivaluedMap<String, String> queryParams = ui.getQueryParameters();
	MultivaluedMap<String, String> pathParams = ui.getPathParameters();
}

The following method extracts header and cookie parameter names and values into a map:
@GET
public String get(@Context HttpHeaders hh) {
	MultivaluedMap<String, String> headerParams = hh.getRequestHeaders();
	Map<String, Cookie> pathParams = hh.getCookies();
}

In general, @Context can be used to obtain contextual Java types related to the request or
response.

For form parameters, it is possible to do the following:
@POST
@Consumes("application/x-www-form-urlencoded")
public void post(MultivaluedMap<String, String> formParams) {
	// Store the message
}

Further Information about JAX-RS
================================
For more information about RESTful web services and JAX-RS, see

“RESTful Web Services vs. ’Big’ Web Services: Making the Right Architectural Decision”:
http://www2008.org/papers/pdf/p805-pautassoA.pdf

“Fielding Dissertation: Chapter 5: Representational State Transfer (REST)”:
http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm

 RESTful Web Services, by Leonard Richardson and Sam Ruby, available from O’Reilly Media
at http://oreilly.com/catalog/9780596529260/

 JSR 311: JAX-RS: The Java API for RESTful Web Services:
http://jcp.org/en/jsr/detail?id=311

JAX-RS project:
http://jsr311.java.net/

Jersey project:
http://jersey.java.net/

JAX-RS: Advanced Topics
=======================

JAX-RS is part of the Java EE 6 full profile. JAX-RS is integrated with Contexts and Dependency
Injection for the Java EE Platform (CDI), Enterprise JavaBeans (EJB) technology, and Java
Servlet technology.

Annotations for Field and Bean Properties of Resource Classes
-------------------------------------------------------------

JAX-RS annotations for resource classes let you extract specific parts or values from a Uniform
Resource Identifier (URI) or request header.

JAX-RS provides the annotations listed in next table

Annotation Description
@Context Injects information into a class field, bean property, or method parameter
@CookieParam Extracts information from cookies declared in the cookie request header
@FormParam Extracts information from a request representation whose content type is
application/x-www-form-urlencoded
@HeaderParam Extracts the value of a header
@MatrixParam Extracts the value of a URI matrix parameter
@PathParam Extracts the value of a URI template parameter
@QueryParam Extracts the value of a URI query parameter

Integrating JAX-RS with EJB Technology and CDI
----------------------------------------------

AX-RS works with Enterprise JavaBeans technology (enterprise beans) and Contexts and
Dependency Injection for the Java EE Platform (CDI).
In general, for JAX-RS to work with enterprise beans, you need to annotate the class of a bean
with @Path to convert it to a root resource class. You can use the @Path annotation with stateless
session beans and singleton POJO beans.

The following code snippet shows a stateless session bean and a singleton bean that have been
converted to JAX-RS root resource classes.

@Stateless
@Path("stateless-bean")
public class StatelessResource {...}

@Singleton
@Path("singleton-bean")
public class SingletonResource {...}

Session beans can also be used for subresources.
JAX-RS and CDI have slightly different component models. By default, JAX-RS root resource
classes are managed in the request scope, and no annotations are required for specifying the
scope. CDI managed beans annotated with @RequestScoped or @ApplicationScoped can be
converted to JAX-RS resource classes.

The following code snippet shows a JAX-RS resource class.
@Path("/employee/{id}")
public class Employee {
public Employee(@PathParam("id") String id) {...}
}
@Path("{lastname}")
public final class EmpDetails {...}

The following code snippet shows this JAX-RS resource class converted to a CDI bean. The
beans must be proxyable, so the Employee class requires a non-private constructor with no
parameters, and the EmpDetails class must not be final.

@Path("/employee/{id}")
@RequestScoped
public class Employee {
public Employee() {...}
@Inject
public Employee(@PathParam("id") String id) {...}
}
@Path("{lastname}")
@RequestScoped
public class EmpDetails {...}


Conditional HTTP Requests
-------------------------

JAX-RS provides support for conditional GET and PUT HTTP requests. Conditional GET
requests help save bandwidth by improving the efficiency of client processing.

A GET request can return a Not Modified (304) response if the representation has not changed
since the previous request. For example, a web site can return 304 responses for all its static
images that have not changed since the previous request.

A PUT request can return a Precondition Failed (412) response if the representation has been
modified since the last request. The conditional PUT can help avoid the lost update problem.

Conditional HTTP requests can be used with the Last-Modified and ETag headers. The
Last-Modified header can represent dates with granularity of one second.

@Path("/employee/{joiningdate}")
public class Employee {

	Date joiningdate;

	@GET
	@Produces("application/xml")
	public Employee(
		@PathParam("joiningdate") Date joiningdate,
		@Context Request req,
		@Context UriInfo ui) {
		
		this.joiningdate = joiningdate;
		...
		this.tag = computeEntityTag(ui.getRequestUri());
		if (req.getMethod().equals("GET")) {
			Response.ResponseBuilder rb = req.evaluatePreconditions(tag);
			if (rb != null) {
				throw new WebApplicationException(rb.build());
			}
		}
	}
}

In this code snippet, the constructor of the Employee class computes the entity tag from the
request URI and calls the request.evaluatePreconditions method with that tag. If a client
request returns an If-none-match header with a value that has the same entity tag that was
computed, evaluate.Preconditions returns a pre-filled-out response with a 304 status code
and an entity tag set that may be built and returned.

Runtime Content Negotiation
---------------------------
The @Produces and @Consumes annotations handle static content negotiation in JAX-RS. These
annotations specify the content preferences of the server. HTTP headers such as Accept,
Content-Type, and Accept-Language define the content negotiation preferences of the client.

For more details on the HTTP headers for content negotiation, see HTTP /1.1 - Content
Negotiation (http://www.w3.org/Protocols/rfc2616/rfc2616-sec12.html).

The following code snippet shows the server content preferences:
@Produces("text/plain")
@Path("/employee")
public class Employee {

	@GET
	public String getEmployeeAddressText(String address) { ... }

	@Produces("text/xml")
	@GET
	public String getEmployeeAddressXml(Address address) { ... }
}

The getEmployeeAddressText method is called for an HTTP request that looks as follows:
GET /employee
Accept: text/plain

This will produce the following response:
500 Oracle Parkway, Redwood Shores, CA

The getEmployeeAddressXml method is called for an HTTP request that looks as follows:
GET /employee
Accept: text/xml

This will produce the following response:
<address street="500 Oracle Parkway, Redwood Shores, CA" country="USA"/>

With static content negotiation, you can also define multiple content and media types for the
client and server.

@Produces("text/plain", "text/xml")

Variant
-------

In addition to supporting static content negotiation, JAX-RS also supports runtime content
negotiation using the javax.ws.rs.core.Variant class and Request objects. The Variant
class specifies the resource representation of content negotiation. Each instance of the Variant
class may contain a media type, a language, and an encoding. The Variant object defines the
resource representation that is supported by the server. The Variant.VariantListBuilder
class is used to build a list of representation variants.

The following code snippet shows how to create a list of resource representation variants:
List<Variant> vs = Variant.mediatypes("application/xml", "application/json").languages("en", "fr").build();

This code snippet calls the build method of the VariantListBuilder class. The
VariantListBuilder class is invoked when you call the mediatypes, languages, or encodings
methods. The build method builds a series of resource representations. The Variant list
created by the build method has all possible combinations of items specified in the
mediatypes, languages, and encodings methods.

The javax.ws.rs.core.Request.selectVariant method accepts a list of Variant objects and
chooses the Variant object that matches the HTTP request. This method compares its list of
Variant objects with the Accept, Accept-Encoding, Accept-Language, and Accept-Charset
headers of the HTTP request.

The following code snippet shows how to use the selectVariant method to select the most
acceptable Variant from the values in the client request.
@GET
public Response get(@Context Request r) {
	List<Variant> vs = ...;
	Variant v = r.selectVariant(vs);
	if (v == null) {
		return Response.notAcceptable(vs).build();
	} else {
		Object rep = selectRepresentation(v);
		return Response.ok(rep, v);
	}
}

The selectVariant method returns the Variant object that matches the request, or null if no
matches are found. In this code snippet, if the method returns null, a Response object for a
non-acceptable response is built. Otherwise, a Response object with an OK status and
containing a representation in the form of an Object entity and a Variant is returned.


Using JAX-RS With JAXB
----------------------
Java Architecture for XML Binding (JAXB) is an XML-to-Java binding technology that
simplifies the development of web services by enabling transformations between schema and
Java objects and between XML instance documents and Java object instances. An XML schema
defines the data elements and structure of an XML document. You can use JAXB APIs and tools
to establish mappings between Java classes and XML schema. JAXB technology provides the
tools that enable you to convert your XML documents to and from Java objects.

By using JAXB, you can manipulate data objects in the following ways:

-You can start with an XML schema definition (XSD) and use xjc, the JAXB schema
compiler tool, to create a set of JAXB-annotated Java classes that map to the elements and
types defined in the XSD schema.

-You can start with a set of Java classes and use schemagen, the JAXB schema generator tool,
to generate an XML schema.

-Once a mapping between the XML schema and the Java classes exists, you can use the JAXB
binding runtime to marshal and unmarshal your XML documents to and from Java objects
and use the resulting Java classes to assemble a web services application.

XML is a common media format that RESTful services consume and produce. To deserialize
and serialize XML, you can represent requests and responses by JAXB annotated objects. Your
JAX-RS application can use the JAXB objects to manipulate XML data. JAXB objects can be
used as request entity parameters and response entities. The JAX-RS runtime environment
includes standard MessageBodyReader and MessageBodyWriter provider interfaces for reading
and writing JAXB objects as entities.

With JAX-RS, you enable access to your services by publishing resources. Resources are just
simple Java classes with some additional JAX-RS annotations. These annotations express the
following:

-The path of the resource (the URL you use to access it)

-The HTTP method you use to call a certain method (for example, the GET or POST method)

-The MIME type with which a method accepts or responds

As you define the resources for your application, consider the type of data you want to expose.
You may already have a relational database that contains information you want to expose to
users, or you may have static content that does not reside in a database but does need to be
distributed as resources. Using JAX-RS, you can distribute content from multiple sources.
RESTful web services can use various types of input/output formats for request and response.
The customer example, described in “The customer Example Application” on page 418, uses
XML.

Resources have representations. A resource representation is the content in the HTTP message
that is sent to, or returned from, the resource using the URI. Each representation a resource
supports has a corresponding media type. For example, if a resource is going to return content
formatted as XML, you can use application/xml as the associated media type in the HTTP
message. Depending on the requirements of your application, resources can return
representations in a preferred single format or in multiple formats. JAX-RS provides @Consumes
and @Produces annotations to declare the media types that are acceptable for a resource
method to read and write.

JAX-RS also maps Java types to and from resource representations using entity providers. A
MessageBodyReader entity provider reads a request entity and deserializes the request entity
into a Java type. A MessageBodyWriter entity provider serializes from a Java type into a
response entity. For example, if a String value is used as the request entity parameter, the
MessageBodyReader entity provider deserializes the request body into a new String. If a JAXB
type is used as the return type on a resource method, the MessageBodyWriter serializes the
JAXB object into a response body.

By default, the JAX-RS runtime environment attempts to create and use a default JAXBContext
class for JAXB classes. However, if the default JAXBContext class is not suitable, then you can
supply a JAXBContext class for the application using a JAX-RS ContextResolver provider
interface.

Using Java Objects to Model Your Data
-------------------------------------
If you do not have an XML schema definition for the data you want to expose, you can model
your data as Java classes, add JAXB annotations to these classes, and use JAXB to generate an
XML schema for your data. For example, if the data you want to expose is a collection of
products and each product has an ID, a name, a description, and a price, you can model it as a
Java class as follows:

@XmlRootElement(name="product")
@XmlAccessorType(XmlAccessType.FIELD)
public class Product {

	@XmlElement(required=true)
	protected int id;

	@XmlElement(required=true)
	protected String name;

	@XmlElement(required=true)
	protected String description;

	@XmlElement(required=true)
	protected int price;
	
	public Product() {}

	// Getter and setter methods
	// ...
}


Run the JAXB schema generator on the command line to generate the corresponding XML
schema definition:

$ schemagen Product.java

This command produces the XML schema as an .xsd file:

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<xs:schema version="1.0" xmlns:xs="http://www.w3.org/2001/XMLSchema">
	
	<xs:element name="product" type="product"/>
	
	<xs:complexType name="product">
		<xs:sequence>
				<xs:element name="id" type="xs:int"/>
				<xs:element name="name" type="xs:string"/>
				<xs:element name="description" type="xs:string"/>
				<xs:element name="price" type="xs:int"/>
		</xs:sequence>
	<xs:complexType>

</xs:schema>

Once you have this mapping, you can create Product objects in your application, return them,
and use them as parameters in JAX-RS resource methods. The JAX-RS runtime uses JAXB to
convert the XML data from the request into a Product object and to convert a Product object
into XML data for the response. The following resource class provides a simple example:


@Path("/product")
public class ProductService {

	@GET
	@Path("/get")
	@Produces("application/xml")
	public Product getProduct() {
		Product prod = new Product();
		prod.setId(1);
		prod.setName("Mattress");
		prod.setDescription("Queen size mattress");
		prod.setPrice(500);
		return prod;
	}
	
	@POST
	@Path("/create")
	@Consumes("application/xml")
	public Response createProduct(Product prod) {
		// Process or store the product and return a response
		// ...
	}
}

Starting from an Existing XML Schema Definition
-----------------------------------------------
If you already have an XML schema definition in an .xsd file for the data you want to expose,
use the JAXB schema compiler tool. Consider this simple example of an .xsd file:

<?xml version="1.0"?>
<xs:schema targetNamespace="http://xml.product"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	elementFormDefault="qualified"
	xmlns:myco="http://xml.product">

	<xs:element name="product" type="myco:Product"/>
	
	<xs:complexType name="Product">
		<xs:sequence>
			<xs:element name="id" type="xs:int"/>
			<xs:element name="name" type="xs:string"/>
			<xs:element name="description" type="xs:string"/>
			<xs:element name="price" type="xs:int"/>
		</xs:sequence>
	</xs:complexType>
</xs:schema>


Run the schema compiler tool on the command line as follows:
$ xjc Product.xsd

This command generates the source code for Java classes that correspond to the types defined in
the .xsd file. The schema compiler tool generates a Java class for each complexType defined in
the .xsd file. The fields of each generated Java class are the same as the elements inside the
corresponding complexType, and the class contains getter and setter methods for these fields.

In this case the schema compiler tool generates the classes product.xml.Product and
product.xml.ObjectFactory. The Product class contains JAXB annotations, and its fields
correspond to those in the .xsd definition:

@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "Product", propOrder = {"id","name","description","price"})
public class Product {

	protected int id;

	@XmlElement(required = true)
	protected String name;
	
	@XmlElement(required = true)
	protected String description;
	
	protected int price;
	
	// Setter and getter methods
	// ...
}

You can create instances of the Product class from your application (for example, from a
database). The generated class product.xml.ObjectFactory contains a method that allows you
to convert these objects to JAXB elements that can be returned as XML inside JAX-RS resource
methods:

@XmlElementDecl(namespace = "http://xml.product", name = "product")
public JAXBElement<Product> createProduct(Product value) {
	return new JAXBElement<Product>(_Product_QNAME, Product.class, null, value);
}

The following code shows how to use the generated classes to return a JAXB element as XML in
a JAX-RS resource method:

@Path("/product")
public class ProductService {

	@GET
	@Path("/get")
	@Produces("application/xml")
	public JAXBElement<Product> getProduct() {
		Product prod = new Product();
		prod.setId(1);
		prod.setName("Mattress");
		prod.setDescription("Queen size mattress");
		prod.setPrice(500);
		return new ObjectFactory().createProduct(prod);
	}
}

For @POST and @PUT resource methods, you can use a Product object directly as a parameter.
JAX-RS maps the XML data from the request into a Product object.

@Path("/product")
public class ProductService {

	@GET
	// ...
	
	@POST
	@Path("/create")
	@Consumes("application/xml")
	public Response createProduct(Product prod) {
		// Process or store the product and return a response
		// ...
	}
}

Using JSON with JAX-RS and JAXB
-------------------------------
JAX-RS can automatically read and write XML using JAXB, but it can also work with JSON
data. JSON is a simple text-based format for data exchange derived from JavaScript. For the
examples above, the XML representation of a product is:

<?xml version="1.0" encoding="UTF-8"?>
<product>
<id>1</id>
<name>Mattress</name>
<description>Queen size mattress</description>
<price>500</price>
</product>

The equivalent JSON representation is:

{
"id":"1",
"name":"Mattress",
"description":"Queen size mattress",
"price":500
}

You can add the format application/json to the @Produces annotation in resource methods
to produce responses with JSON data:

@GET
@Path("/get")
@Produces({"application/xml","application/json"})
public Product getProduct() { ... }

In this example the default response is XML, but the response is a JSON object if the client
makes a GET request that includes this header:
Accept: application/json

The resource methods can also accept JSON data for JAXB annotated classes:

@POST
@Path("/create")
@Consumes({"application/xml","application/json"})
public Response createProduct(Product prod) { ... }

The client should include the following header when submitting JSON data with a POST request:
Content-Type: application/json


page 418 (Example Application)


//guias de primera implemenetacion

https://www.mkyong.com/webservices/jax-ws/deploy-jax-ws-web-services-on-tomcat/
https://examples.javacodegeeks.com/enterprise-java/jws/jax-ws-web-services-on-tomcat/
https://www.javacodegeeks.com/2012/03/web-services-with-jax-ws-on-tomcat.html
https://jaxenter.com/creating-soap-web-services-using-jax-ws-117689.html
http://stackoverflow.com/questions/12581751/sun-jaxws-xml-when-is-it-needed-and-when-not
http://docs.oracle.com/cd/E17802_01/webservices/webservices/docs/2.0/jaxws/jaxws-war.html
http://ics.upjs.sk/~novotnyr/blog/2068/deploying-jax-ws-services-on-java-7-and-tomcat-7











