Web Services Quickstart
-----------------------

Although the term web service has various, imprecise, and evolving meanings, a working
definition should be enough for the upcoming code example, which consists of a service
and a client, also known as a consumer or requester. As the name suggests, a web service
is a kind of webified application—an application typically delivered over HTTP (Hy‐
perText Transport Protocol). HTTPS (HTTP Secure) adds a security layer to HTTP;
hence, a service delivered over HTTPS likewise counts as a web service. Until the main
topic of interest is web service security, HTTP should be understood to include HTTPS.

An HTTP request goes, by definition, from client to server, and an HTTP response goes,
also by definition, from server to client. For web services over HTTP, the HTTP mes‐
sages are the infrastructure, and these HTTP messages can be combined into basic
conversational patterns that characterize a web service. For example, if the web service
conversation starts with an HTTP request that expects an HTTP response, the pattern
is the familiar request/response conversation. By contrast, if the conversation starts with
an HTTP message from the server, a message that expects a message from the client in
return, then the pattern is solicit/response. Richer conversational patterns can be com‐
posed out of such basic two-message patterns. Indeed, these two-message patterns are
composed of even more primitive ones: a message from client to server without a re‐
sponse is a pattern known as one-way, and the reverse pattern, from server to client
without a client response, is known as notification. Web services tend to be simple in
structure. The four conversational patterns enumerated just now cover most modern
web services, and request/response is the pattern that still dominates.

Web services come in two popular flavors: SOAP-based and REST-style. SOAP is an
XML dialect with a grammar that specifies the structure that a document must have in
order to count as SOAP. In a typical SOAP-based service, the client sends SOAP messages
to the service and the service responds in kind, with SOAP messages. REST-style services
are hard to characterize in a sentence or two, but with respect to pattern, these services
tend to be request/response; the same holds for SOAP-based services. For now, a REST-
style service is one that treats HTTP not only as transport infrastructure but also as a
set of guidelines for designing service requests and service responses. In a REST-style
service, HTTP itself can be seen as an API. SOAP has standards, toolkits, and bountiful
software libraries. REST has no official standards, comparatively few toolkits, and un‐
even software libraries among programming languages. Yet there is growing support
for REST-style services across programming languages; hence, it seems only a matter
of time until toolkits and libraries for REST-style services mature.

From a historical perspective, the RESTful approach to web services can be viewed as
an antidote to the creeping complexity of SOAP-based web services. SOAP-based serv‐
ices are designed to be transport-neutral; as a result, SOAP messaging may seem overly
complicated if the transport is, in fact, HTTP.

At present, the distinction
between the two flavors of web service is not sharp, because a SOAP-based service
delivered over HTTP can be seen as a special case of a REST-style service; HTTP remains
the dominant transport for SOAP-based services.

SOAP originally stood for Simple Object Access Protocol and then, by serendipity but
never officially, might have stood for Service-Oriented Architecture (SOA) Protocol.
(SOA is discussed in the section “Web Services and Service-Oriented Architecture” on
page 7.) The World Wide Web Consortium (hereafter, W3C) currently oversees SOAP,
and SOAP is officially no longer an acronym.

Web Service Miscellany
----------------------
Except in test mode, the client of either a SOAP-based or REST-style service is rarely a
web browser but, rather, usually an application without a graphical user interface. The
client may be written in any language with the appropriate support libraries. Indeed, a
major appeal of web services is language transparency: the service and its clients need
not be written in the same language. Language transparency is a key contributor to web
service interoperability—that is, the ability of web services and their consumers to in‐
teract seamlessly despite differences in programming languages, support libraries, op‐
erating systems, and hardware platforms.

There is no magic in language transparency, of course. If a web service written in Java
can have a Python or a Ruby consumer, there must be an intermediary layer that handles
the differences in data types between the service and the client languages. XML tech‐
nologies, which support structured document interchange and processing, act as one
such intermediary level. Another intermediary level is JSON (JavaScript Object Nota‐
tion). XML and JSON are both data-interchange formats, but JSON clearly has the upper
hand with data receivers written in JavaScript because a JSON document is the text
representation of a native JavaScript object. Web service clients are increasingly Java‐
Script programs embedded in HTML documents and executing in a browser; such
clients process JSON with less fuss than they do XML. Even among non-JavaScript
clients, JSON has gained in popularity; for one thing, JSON is more readable than XML
because JSON has relatively less markup.

Several features distinguish web services from other distributed software systems. Here
are three:

Open infrastructure
Web services are deployed using industry-standard, vendor-independent protocols
and languages such as HTTP, XML, and JSON, all of which are ubiquitous and well
understood. Web services can piggyback on networking, data formatting, security,
and other infrastructures already in place, which lowers entry costs and promotes
interoperability among services. Organizations that publish websites with
production-grade web servers such as Apache2, IIS, and Nginx can publish web
services with these very web servers. Firewalls and other security mechanisms that
defend websites thereby defend web services as well.

Platform and language transparency
Web services and their clients can interoperate even if written in different pro‐
gramming languages. Languages such as C, C#, Go, Java, JavaScript, Perl, Python,
Ruby, and others provide libraries, utilities, and even frameworks in support of web
services. Web services can be published and consumed on various hardware plat‐
forms and under different operating systems. Web services are an excellent way to
integrate diverse software systems while allowing the programmer to work in the
programmer’s language of choice. The web service approach to software develop‐
ment is not to rewrite but, rather, to integrate.

Modular design
Web services are meant to be modular in design so that new services can be com‐
posed out of existing ones. Imagine, for example, an inventory-tracking service
integrated with an online ordering service to compose a service that automatically
orders the appropriate products in response to inventory levels. Web services are
the small software parts out of which arbitrarily large systems can be built. A guiding
principle in web service design is to begin with very simple service operations,
essentially uncomplicated functions, and then group these operations into services,
which in turn can be orchestrated to work with other services, and so on indefinitely.

As noted earlier, web services come in different flavors: SOAP-based and REST-style.
SOAP and SOA, though related, remain distinct. The next section goes into detail about
the relationship between SOA and REST-style and SOAP-based web services.

Web Services and Service-Oriented Architecture
----------------------------------------------

Web services and SOA are related but distinct. SOA, like REST, is more an architectural
style—indeed, a mindset—than a body of precisely defined rules for the design and
implementation of distributed systems; web services are a natural, important way to
provide the services at the core of any SOA system. A fundamental idea in SOA is that
an application results from integrating network-accessible services, which are intero‐
perable because each has an interface that clearly defines the operations encapsulated
in the service. Per operation, the interface specifies the number and type of each argu‐
ment passed to the service operation together with the number and type of values re‐
turned from each service operation. The very point of a service interface is to publish
the invocation syntax of each operation encapsulated in the service. One attraction of
the SOA approach is that the ultimate building blocks of even large, complicated systems
are structurally simple components; this simplicity at the base level makes it relatively
easy to test, debug, deploy, extend, and otherwise maintain a software system.

In an SOA system, services as building block components may be characterized as
unassociated and loosely coupled. Consider, for example, two primitive services, S 1 and
S 2 , in an SOA application. The two services are unassociated in that neither S 1 nor S 2
depends on the other: S 1 is not required to use S 2 or vice versa. The services are mutually
independent but can be used together or orchestrated as parts of a larger software sys‐
tem. Following the same theme, components such as S 1 and S 2 are loosely coupled in
that neither needs to know anything about the internal structure of the other in order
for both of these services to work together as parts of a larger distributed system. A
persistent theme in the many discussions of SOA is the modularity of SOA-based
systems.

At the implementation level, a service operation is a function call: the function takes
zero or more arguments and returns zero or more values. Although functions in many
languages such as C and even Java technically return, at most, only a single value and
therefore must resort to aggregate data structures such as a lists to return multiple values,
newer languages such as Go have uncomplicated syntax for functions to return arbi‐
trarily many values including, of course, none. This fact underscores the inherent rich‐
ness and flexibility of the function as a system building block. Programmers fluent in
virtually any language are thereby knowledgeable about the syntax and semantics of
functions.

In an SOA system, a very simple service may consist of a single function. The imple‐
mentation model is thus uncomplicated and familiar to programmers, and the simplicity
of service operations promotes code reuse through the composition of new services out
of existing ones. This ground-level simplicity also enables relatively straightforward
troubleshooting because services reduce to primitive function calls. An SOA system can
be quite complicated, of course, but the complication arises from the composition and
not from the simple services into which the system ultimately decomposes.

Web services are well suited as components in an SOA system. Following best practices,
a web service should consist of operations, each of which is implemented as a stateless
function call: the call is stateless in that the return value(s) depend only on the arguments
passed to the call. In an object-oriented language such as a Java, a well-designed web
service is a class that has instance methods as service operations but no instance fields
that impact the value returned from a particular method. In practice, statelessness is
easier said than done, as the many examples in this book illustrate. In the context of
SOA, it is common to distinguish between providers and consumers of web services: the
provider furnishes the service’s functionality, and the consumer is a client that issues
requests against the service’s operations. The provider/consumer pair is commonly used
to describe web services and their clients, respectively.

Perhaps the best way to clarify SOA in the concrete is to contrast this approach to
distributed systems with a quite different approach: DOA (Distributed Object Archi‐
tecture). Web services came to fore as a reaction against the complexity of DOA systems.
The next section provides a short history of web services, with emphasis on the kinds
of software challenges that web services are meant to address.

A Very Short History of Web Services
Web services evolved from the RPC (Remote Procedure Call) mechanism in DCE (Dis‐
tributed Computing Environment), a framework for software development from the
early 1990s. DCE includes a distributed filesystem (DCE/DFS) and a Kerberos-based
authentication system. Although DCE has its origins in the Unix world, Microsoft
quickly did its own implementation known as MSRPC, which in turn served as the
infrastructure for interprocess communication in Windows. Microsoft’s COM/OLE
(Common Object Model/Object Linking and Embedding) technologies and services
were built on a DCE/RPC foundation. There is irony here. DCE designed RPC as a way
to do distributed computing (i.e., computing across distinct physical devices), and Mi‐
crosoft cleverly adapted RPC to support interprocess communication, in the form of
COM infrastructure, on a single device—a PC running Windows.

The first-generation frameworks for distributed object systems, CORBA (Common
Object Request Broker Architecture) and Microsoft’s DCOM (Distributed COM), are
anchored in the DCE/RPC procedural framework. Java RMI (Remote Method Invoca‐
tion) also derives from DCE/RPC, and the method calls in Java EE (Enterprise Edition),
specifically in Session and Entity EJBs (Enterprise Java Bean), are Java RMI calls. Java
EE (formerly J2EE) and Microsoft’s DotNet are second-generation frameworks for dis‐
tributed object systems, and these frameworks, like CORBA and DCOM before them,
trace their ancestry back to DCE/RPC. By the way, DCE/RPC is not dead. Various
popular system utilities (for instance, the Samba file and print service for Windows
clients) use DCE/RPC.

From DCE/RPC to XML-RPC
DCE/RPC has the familiar client/server architecture in which a client invokes a proce‐
dure that executes on the server. Arguments can be passed from the client to the server
and return values can be passed from the server to the client. The framework is platform-
and language- neutral in principle, although strongly tilted toward C in practice. DCE/
RPC includes utilities for generating client and server artifacts (stubs and skeletons,
respectively). DCE/RPC also provides software libraries that hide the transport details.
Of interest now is the IDL (Interface Definition Language) document that acts as the
service contract and is an input to utilities that generate artifacts in support of the DCE/
RPC calls. An IDL document can be short and to the point

/* echo.idl */
[uuid(2d6ead46-05e3-11ca-7dd1-426909beabcd), version(1.0)]
interface echo {
	const long int ECHO_SIZE = 512;

	void echo(
				[in]			handle_t h,
				[in, string]	idl_char from_client[],
				[out, string]	idl_char from_server[ECHO_SIZE]
	);
}

The IDL interface named echo , identified with a machine-generated UUID (Universally
Unique IDentifier), declares a single function with the same name, echo . The names are
arbitrary and need not be the same. The echo function expects three arguments, two of
which are in parameters (that is, inputs into the remote procedure) and one of which
is an out parameter (that is, an output from the remote procedure). The first argument,
of built-in type handle_t , is required and points to an RPC data structure. The function
echo could but does not return a value, because the echoed string is returned instead as
an out parameter. The IDL specifies the invocation syntax for the echo function, which
is the one and only operation in the service. Except for annotations in square brackets
to the left of the three echo parameters, the syntax of the IDL is essentially C syntax.
The IDL document is a precursor of the WSDL (Web Service Description Language)
document that provides a formal specification of a web service and its operations.

There is a Microsoft twist to the IDL story as well. An ActiveX control under Windows
is a DLL (Dynamic Link Library) with an embedded typelib, which in turn is a compiled
IDL file. For example, suppose that a calendar ActiveX control is plugged into a browser.
The browser can read the typelib, which contains the invocation syntax for each oper‐
ation (e.g., displaying the next month) in the control. An ActiveX control is thus a chunk
of software that embeds its own interface. This is yet another inspired local use of a
technology designed for distributed computing.

In the late 1990s, Dave Winer of UserLand Software developed XML-RPC, a technology
innovation that has as good a claim as any to mark the birth of web services. XML-RPC
is a very lightweight RPC system with support for elementary data types (basically, the
built-in C types together with a boolean and a datetime type) and a few simple com‐
mands. The original specification is about seven pages in length. The two key features
are the use of XML marshaling/unmarshaling to achieve language neutrality and reli‐
ance on HTTP (and, later, SMTP) for transport. The term marshaling refers to the
conversion of an in-memory object (for instance, an Employee object in Java) to some
other format (for instance, an XML document); unmarshaling refers to the inverse pro‐
cess of generating an in-memory object from, in this example, an XML document. The
marshal/unmarshal distinction is somewhere between close to and identical with the
serialize/deserialize distinction. My habit is to use the distinctions interchangeably. In
any case, the O’Reilly open-wire Meerkat service and the WordPress publishing plat‐
form are based on XML-RPC.

Two key differences separate XML-RPC, on the one side, from DCE/RPC and its off-
shoots, on the other side:

- XML-RPC payloads are text, whereas DCE/RPC payloads are binary. Text is rela‐
tively easy to inspect and process with standard, readily available tools such as
editors and parsers.
- XML-RPC transport uses HTTP rather than a proprietary system. To support XML-
RPC, a programming language requires only a standard HTTP library together
with libraries to generate, parse, transform, and otherwise process XML.

As an RPC technology, XML-RPC supports the request/response pattern. Here is the
XML request to invoke, on a remote machine, the Fibonacci function with an argument
of 11. This argument is passed as a 4-byte integer, as the XML start tag <i4> indicates:

<?xml version="1.0">
<methodCall>
	<methodName>fib<methodName>

	<params>
		<param>
			<value>
				<i4>11</i4>
			</value>
		</param>
	</params>
</methodCall>

The integer 11 occurs in the XML-RPC message as text. An XML-RPC library on the
receiving end needs to extract 11 as text and then convert the text into a 4-byte integer
in the receiving language such as Go or Java. Even this short example illustrates the idea
of having XML—in particular, data types expressed in XML—serve as the leveling
mechanism between two different languages involved in an XML-RPC exchange.

XML-RPC is deliberately low fuss and lightweight. SOAP, an XML dialect derived
straight from XML-RPC, is considerably heavier in weight. From inception, XML-RPC
faced competition from second-generation DOA systems such as Java EE (J2EE) and
AspNet. The next section considers the challenges inherent in DOA systems. These
challenges sustained and eventually intensified interest in lighter-weight approaches to
distributed computing—modern web services.

Distributed Object Architecture: A Java Example
-----------------------------------------------
What advantages do web services have over DOA technologies such as Java RMI? This
section addresses the question with an example. Java RMI (including the Session and
Entity EJB constructs built on Java RMI) and DotNet Remoting are examples of second-
generation distributed object systems. Consider what a Java RMI client requires in order
to invoke a method declared in a service interface such as this:

import java.util.List;
public interface BenefitsService extends java.rmi.Remote {
	public List<Benefit> getBenefits(Emp emp) throws RemoteException;
}

The interface appears deceptively simple in that it declares only the method named
getBenefits , yet the interface likewise hints at what makes a Distributed Object Ar‐
chitecture so tricky. A client against this BenefitsService requires a Java RMI stub, an
instance of a class that implements the BenefitsService interface. The stub is down‐
loaded automatically from the server to the client as part of the Java RMI setup

Once the stub setup is done, the getBenefits method is executed as a stub method;
that is, the stub acts as the client-side object making a remote method call through one
of stub’s encapsulated methods. The call thus has the following syntax:

Emp fred = new Emp();
//...
List<Benefit> benefits = rmiStub.getBenefits(fred); // rmiStub = reference

Invoking the getBenefits method requires that the byte codes for various Java classes,
standard and programmer-defined, be available on the client machine. To begin, the
client needs the class Emp , the argument type for the getBenefits method, and the class
Benefit , the member type for the List that the method getBenefits returns. Suppose
that the class Emp begins like this:

public class Emp {
	private Department
	department;
	private List<BusinessCertification> certifications;
	private List<ClientAccount>
	accounts;
	private Map<String, Contact>
	contacts;
	...
}

The standard Java types such as List and Map are already available on the client side
because the client is, by assumption, a Java application. The challenge involves the ad‐
ditional, programmer-defined types such as Department , BusinessCertification ,
ClientAccount , and Contact that are needed to support the client-side invocation of a
remotely executed method. The setup on the client side to enable a remote call such as:

Emp fred = new Emp();
// set properties, etc.
List<EmpBenefits> fredBenefits = rmiStub.getBenefits(fred);	

is significant, with lots and lots of bytes required to move from the server down to the
client just for the setup. Anything this complicated is, of course, prone to problems such
as versioning issues and outright errors in the remote method calls.

Java RMI uses proprietary marshaling/unmarshaling and proprietary transport, and
DotNet does the same. There are third-party libraries for interoperability between the
two frameworks. Yet a Java RMI service can be expected to have mostly Java clients, and
a DotNet Remoting service can be expected to have mostly DotNet clients. Web services
represent a move toward standardization, simplicity, and interoperability.

Web Services to the Rescue
--------------------------
Web services simplify matters in distributed computing. For one thing, the client and
service typically exchange XML or equivalent documents, that is, text. If needed, non-
text bytes can be exchanged instead, but the preferred payloads are text. The exchanged
text can be inspected, validated, transformed, persisted, and otherwise processed using
readily available, nonproprietary, and often free tools. Each side, client and service,
simply needs a local software library that binds language-specific types such as the Java
String to XML Schema or comparable types, in this case xsd:string . (In the qualified
name xsd:string , xsd is a namespace abbreviation and string is a local name. Of
interest here is that xsd:string is an XML type rather than a Java type.) Given these
Java/XML bindings, relatively uncomplicated library modules can convert from one to
the other—from Java to XML or from XML to Java

Processing on the client side, as on the service side, requires only locally available li‐
braries and utilities. The complexities, therefore, can be isolated at the endpoints—the
service and the client applications together with their supporting libraries—and need
not seep into the exchanged messages. Finally, web services are available over HTTP, a
nonpropriety protocol that has become standard, ubiquitous infrastructure; HTTP in
particular comes with a security extension, HTTPS, that provides multifaceted security
services.

In a web service, the requesting client and the service need not be coded in the same
language or even in the same style of language. Clients and services can be implemented
in object-oriented, procedural, functional, and other language styles. The languages on
either end may be statically typed (for instance, Java and Go) or dynamically typed (for
example, JavaScript and Ruby). The complexities of stubs and skeletons, the serializing
and deserializing of objects encoded in some proprietary format, give way to relatively
simple text-based representations of messages exchanged over standard transports such
as HTTP. The messages themselves are neutral; they have no bias toward a particular
language or even family of languages.

What Is REST?

Roy Fielding coined the acronym REST in his PhD dissertation. Chapter 5 of Fielding’s
dissertation lays out the guiding principles for what have come to be known as REST-
style or RESTful web services. Fielding has an impressive résumé. He is, among other
things, a principal author of the HTTP 1.1 specification and a cofounder of the Apache
Software Foundation.

REST and SOAP are quite different. SOAP is a messaging protocol in which the messages
are XML documents, whereas REST is a style of software architecture for distributed
hypermedia systems, or systems in which text, graphics, audio, and other media are
stored across a network and interconnected through hyperlinks. The World Wide Web
is the obvious example of such a system. As the focus here is on web services, the World
Wide Web is the distributed hypermedia system of interest. In the Web, HTTP is both
a transport protocol and a messaging system because HTTP requests and responses are
messages. The payloads of HTTP messages can be typed using the MIME (Multipurpose
Internet Mail Extension) type system. MIME has types such as text/html , applica
tion/octet-stream , and audio/mpeg3 . HTTP also provides response status codes to
inform the requester about whether a request succeeded and, if not, why. next Table lists
some common status codes.

Status 	code In English		Meaning
200 	OK	Request 		OK
303 	See Other			Redirect
400 	Bad Request			Request malformed
401 	Unauthorized		Authentication error
403 	Forbidden			Request refused
404 	Not Found			Resource not found
405 	Method Not Allowed	Method not supported
415 	Unsupported Media 	Type Content type not recognized
500 	Internal Server Error	Request processing failed







pag 14