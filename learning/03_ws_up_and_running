Web Services Quickstart
-----------------------

Although the term web service has various, imprecise, and evolving meanings, a working
definition should be enough for the upcoming code example, which consists of a service
and a client, also known as a consumer or requester. As the name suggests, a web service
is a kind of webified application—an application typically delivered over HTTP (Hy‐
perText Transport Protocol). HTTPS (HTTP Secure) adds a security layer to HTTP;
hence, a service delivered over HTTPS likewise counts as a web service. Until the main
topic of interest is web service security, HTTP should be understood to include HTTPS.

An HTTP request goes, by definition, from client to server, and an HTTP response goes,
also by definition, from server to client. For web services over HTTP, the HTTP mes‐
sages are the infrastructure, and these HTTP messages can be combined into basic
conversational patterns that characterize a web service. For example, if the web service
conversation starts with an HTTP request that expects an HTTP response, the pattern
is the familiar request/response conversation. By contrast, if the conversation starts with
an HTTP message from the server, a message that expects a message from the client in
return, then the pattern is solicit/response. Richer conversational patterns can be com‐
posed out of such basic two-message patterns. Indeed, these two-message patterns are
composed of even more primitive ones: a message from client to server without a re‐
sponse is a pattern known as one-way, and the reverse pattern, from server to client
without a client response, is known as notification. Web services tend to be simple in
structure. The four conversational patterns enumerated just now cover most modern
web services, and request/response is the pattern that still dominates.

Web services come in two popular flavors: SOAP-based and REST-style. SOAP is an
XML dialect with a grammar that specifies the structure that a document must have in
order to count as SOAP. In a typical SOAP-based service, the client sends SOAP messages
to the service and the service responds in kind, with SOAP messages. REST-style services
are hard to characterize in a sentence or two, but with respect to pattern, these services
tend to be request/response; the same holds for SOAP-based services. For now, a REST-
style service is one that treats HTTP not only as transport infrastructure but also as a
set of guidelines for designing service requests and service responses. In a REST-style
service, HTTP itself can be seen as an API. SOAP has standards, toolkits, and bountiful
software libraries. REST has no official standards, comparatively few toolkits, and un‐
even software libraries among programming languages. Yet there is growing support
for REST-style services across programming languages; hence, it seems only a matter
of time until toolkits and libraries for REST-style services mature.

From a historical perspective, the RESTful approach to web services can be viewed as
an antidote to the creeping complexity of SOAP-based web services. SOAP-based serv‐
ices are designed to be transport-neutral; as a result, SOAP messaging may seem overly
complicated if the transport is, in fact, HTTP.

At present, the distinction
between the two flavors of web service is not sharp, because a SOAP-based service
delivered over HTTP can be seen as a special case of a REST-style service; HTTP remains
the dominant transport for SOAP-based services.

SOAP originally stood for Simple Object Access Protocol and then, by serendipity but
never officially, might have stood for Service-Oriented Architecture (SOA) Protocol.
(SOA is discussed in the section “Web Services and Service-Oriented Architecture” on
page 7.) The World Wide Web Consortium (hereafter, W3C) currently oversees SOAP,
and SOAP is officially no longer an acronym.

Web Service Miscellany
----------------------
Except in test mode, the client of either a SOAP-based or REST-style service is rarely a
web browser but, rather, usually an application without a graphical user interface. The
client may be written in any language with the appropriate support libraries. Indeed, a
major appeal of web services is language transparency: the service and its clients need
not be written in the same language. Language transparency is a key contributor to web
service interoperability—that is, the ability of web services and their consumers to in‐
teract seamlessly despite differences in programming languages, support libraries, op‐
erating systems, and hardware platforms.

There is no magic in language transparency, of course. If a web service written in Java
can have a Python or a Ruby consumer, there must be an intermediary layer that handles
the differences in data types between the service and the client languages. XML tech‐
nologies, which support structured document interchange and processing, act as one
such intermediary level. Another intermediary level is JSON (JavaScript Object Nota‐
tion). XML and JSON are both data-interchange formats, but JSON clearly has the upper
hand with data receivers written in JavaScript because a JSON document is the text
representation of a native JavaScript object. Web service clients are increasingly Java‐
Script programs embedded in HTML documents and executing in a browser; such
clients process JSON with less fuss than they do XML. Even among non-JavaScript
clients, JSON has gained in popularity; for one thing, JSON is more readable than XML
because JSON has relatively less markup.

Several features distinguish web services from other distributed software systems. Here
are three:

Open infrastructure
Web services are deployed using industry-standard, vendor-independent protocols
and languages such as HTTP, XML, and JSON, all of which are ubiquitous and well
understood. Web services can piggyback on networking, data formatting, security,
and other infrastructures already in place, which lowers entry costs and promotes
interoperability among services. Organizations that publish websites with
production-grade web servers such as Apache2, IIS, and Nginx can publish web
services with these very web servers. Firewalls and other security mechanisms that
defend websites thereby defend web services as well.

Platform and language transparency
Web services and their clients can interoperate even if written in different pro‐
gramming languages. Languages such as C, C#, Go, Java, JavaScript, Perl, Python,
Ruby, and others provide libraries, utilities, and even frameworks in support of web
services. Web services can be published and consumed on various hardware plat‐
forms and under different operating systems. Web services are an excellent way to
integrate diverse software systems while allowing the programmer to work in the
programmer’s language of choice. The web service approach to software develop‐
ment is not to rewrite but, rather, to integrate.

Modular design
Web services are meant to be modular in design so that new services can be com‐
posed out of existing ones. Imagine, for example, an inventory-tracking service
integrated with an online ordering service to compose a service that automatically
orders the appropriate products in response to inventory levels. Web services are
the small software parts out of which arbitrarily large systems can be built. A guiding
principle in web service design is to begin with very simple service operations,
essentially uncomplicated functions, and then group these operations into services,
which in turn can be orchestrated to work with other services, and so on indefinitely.

As noted earlier, web services come in different flavors: SOAP-based and REST-style.
SOAP and SOA, though related, remain distinct. The next section goes into detail about
the relationship between SOA and REST-style and SOAP-based web services.

Web Services and Service-Oriented Architecture
----------------------------------------------

Web services and SOA are related but distinct. SOA, like REST, is more an architectural
style—indeed, a mindset—than a body of precisely defined rules for the design and
implementation of distributed systems; web services are a natural, important way to
provide the services at the core of any SOA system. A fundamental idea in SOA is that
an application results from integrating network-accessible services, which are intero‐
perable because each has an interface that clearly defines the operations encapsulated
in the service. Per operation, the interface specifies the number and type of each argu‐
ment passed to the service operation together with the number and type of values re‐
turned from each service operation. The very point of a service interface is to publish
the invocation syntax of each operation encapsulated in the service. One attraction of
the SOA approach is that the ultimate building blocks of even large, complicated systems
are structurally simple components; this simplicity at the base level makes it relatively
easy to test, debug, deploy, extend, and otherwise maintain a software system.

In an SOA system, services as building block components may be characterized as
unassociated and loosely coupled. Consider, for example, two primitive services, S 1 and
S 2 , in an SOA application. The two services are unassociated in that neither S 1 nor S 2
depends on the other: S 1 is not required to use S 2 or vice versa. The services are mutually
independent but can be used together or orchestrated as parts of a larger software sys‐
tem. Following the same theme, components such as S 1 and S 2 are loosely coupled in
that neither needs to know anything about the internal structure of the other in order
for both of these services to work together as parts of a larger distributed system. A
persistent theme in the many discussions of SOA is the modularity of SOA-based
systems.

At the implementation level, a service operation is a function call: the function takes
zero or more arguments and returns zero or more values. Although functions in many
languages such as C and even Java technically return, at most, only a single value and
therefore must resort to aggregate data structures such as a lists to return multiple values,
newer languages such as Go have uncomplicated syntax for functions to return arbi‐
trarily many values including, of course, none. This fact underscores the inherent rich‐
ness and flexibility of the function as a system building block. Programmers fluent in
virtually any language are thereby knowledgeable about the syntax and semantics of
functions.

In an SOA system, a very simple service may consist of a single function. The imple‐
mentation model is thus uncomplicated and familiar to programmers, and the simplicity
of service operations promotes code reuse through the composition of new services out
of existing ones. This ground-level simplicity also enables relatively straightforward
troubleshooting because services reduce to primitive function calls. An SOA system can
be quite complicated, of course, but the complication arises from the composition and
not from the simple services into which the system ultimately decomposes.

Web services are well suited as components in an SOA system. Following best practices,
a web service should consist of operations, each of which is implemented as a stateless
function call: the call is stateless in that the return value(s) depend only on the arguments
passed to the call. In an object-oriented language such as a Java, a well-designed web
service is a class that has instance methods as service operations but no instance fields
that impact the value returned from a particular method. In practice, statelessness is
easier said than done, as the many examples in this book illustrate. In the context of
SOA, it is common to distinguish between providers and consumers of web services: the
provider furnishes the service’s functionality, and the consumer is a client that issues
requests against the service’s operations. The provider/consumer pair is commonly used
to describe web services and their clients, respectively.

Perhaps the best way to clarify SOA in the concrete is to contrast this approach to
distributed systems with a quite different approach: DOA (Distributed Object Archi‐
tecture). Web services came to fore as a reaction against the complexity of DOA systems.
The next section provides a short history of web services, with emphasis on the kinds
of software challenges that web services are meant to address.

A Very Short History of Web Services
Web services evolved from the RPC (Remote Procedure Call) mechanism in DCE (Dis‐
tributed Computing Environment), a framework for software development from the
early 1990s. DCE includes a distributed filesystem (DCE/DFS) and a Kerberos-based
authentication system. Although DCE has its origins in the Unix world, Microsoft
quickly did its own implementation known as MSRPC, which in turn served as the
infrastructure for interprocess communication in Windows. Microsoft’s COM/OLE
(Common Object Model/Object Linking and Embedding) technologies and services
were built on a DCE/RPC foundation. There is irony here. DCE designed RPC as a way
to do distributed computing (i.e., computing across distinct physical devices), and Mi‐
crosoft cleverly adapted RPC to support interprocess communication, in the form of
COM infrastructure, on a single device—a PC running Windows.

The first-generation frameworks for distributed object systems, CORBA (Common
Object Request Broker Architecture) and Microsoft’s DCOM (Distributed COM), are
anchored in the DCE/RPC procedural framework. Java RMI (Remote Method Invoca‐
tion) also derives from DCE/RPC, and the method calls in Java EE (Enterprise Edition),
specifically in Session and Entity EJBs (Enterprise Java Bean), are Java RMI calls. Java
EE (formerly J2EE) and Microsoft’s DotNet are second-generation frameworks for dis‐
tributed object systems, and these frameworks, like CORBA and DCOM before them,
trace their ancestry back to DCE/RPC. By the way, DCE/RPC is not dead. Various
popular system utilities (for instance, the Samba file and print service for Windows
clients) use DCE/RPC.

From DCE/RPC to XML-RPC
DCE/RPC has the familiar client/server architecture in which a client invokes a proce‐
dure that executes on the server. Arguments can be passed from the client to the server
and return values can be passed from the server to the client. The framework is platform-
and language- neutral in principle, although strongly tilted toward C in practice. DCE/
RPC includes utilities for generating client and server artifacts (stubs and skeletons,
respectively). DCE/RPC also provides software libraries that hide the transport details.
Of interest now is the IDL (Interface Definition Language) document that acts as the
service contract and is an input to utilities that generate artifacts in support of the DCE/
RPC calls. An IDL document can be short and to the point

/* echo.idl */
[uuid(2d6ead46-05e3-11ca-7dd1-426909beabcd), version(1.0)]
interface echo {
	const long int ECHO_SIZE = 512;

	void echo(
				[in]			handle_t h,
				[in, string]	idl_char from_client[],
				[out, string]	idl_char from_server[ECHO_SIZE]
	);
}

The IDL interface named echo , identified with a machine-generated UUID (Universally
Unique IDentifier), declares a single function with the same name, echo . The names are
arbitrary and need not be the same. The echo function expects three arguments, two of
which are in parameters (that is, inputs into the remote procedure) and one of which
is an out parameter (that is, an output from the remote procedure). The first argument,
of built-in type handle_t , is required and points to an RPC data structure. The function
echo could but does not return a value, because the echoed string is returned instead as
an out parameter. The IDL specifies the invocation syntax for the echo function, which
is the one and only operation in the service. Except for annotations in square brackets
to the left of the three echo parameters, the syntax of the IDL is essentially C syntax.
The IDL document is a precursor of the WSDL (Web Service Description Language)
document that provides a formal specification of a web service and its operations.

There is a Microsoft twist to the IDL story as well. An ActiveX control under Windows
is a DLL (Dynamic Link Library) with an embedded typelib, which in turn is a compiled
IDL file. For example, suppose that a calendar ActiveX control is plugged into a browser.
The browser can read the typelib, which contains the invocation syntax for each oper‐
ation (e.g., displaying the next month) in the control. An ActiveX control is thus a chunk
of software that embeds its own interface. This is yet another inspired local use of a
technology designed for distributed computing.



pag 10