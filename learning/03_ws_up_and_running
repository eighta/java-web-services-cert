Web Services Quickstart
-----------------------

Although the term web service has various, imprecise, and evolving meanings, a working
definition should be enough for the upcoming code example, which consists of a service
and a client, also known as a consumer or requester. As the name suggests, a web service
is a kind of webified application—an application typically delivered over HTTP (Hy‐
perText Transport Protocol). HTTPS (HTTP Secure) adds a security layer to HTTP;
hence, a service delivered over HTTPS likewise counts as a web service. Until the main
topic of interest is web service security, HTTP should be understood to include HTTPS.

An HTTP request goes, by definition, from client to server, and an HTTP response goes,
also by definition, from server to client. For web services over HTTP, the HTTP mes‐
sages are the infrastructure, and these HTTP messages can be combined into basic
conversational patterns that characterize a web service. For example, if the web service
conversation starts with an HTTP request that expects an HTTP response, the pattern
is the familiar request/response conversation. By contrast, if the conversation starts with
an HTTP message from the server, a message that expects a message from the client in
return, then the pattern is solicit/response. Richer conversational patterns can be com‐
posed out of such basic two-message patterns. Indeed, these two-message patterns are
composed of even more primitive ones: a message from client to server without a re‐
sponse is a pattern known as one-way, and the reverse pattern, from server to client
without a client response, is known as notification. Web services tend to be simple in
structure. The four conversational patterns enumerated just now cover most modern
web services, and request/response is the pattern that still dominates.

Web services come in two popular flavors: SOAP-based and REST-style. SOAP is an
XML dialect with a grammar that specifies the structure that a document must have in
order to count as SOAP. In a typical SOAP-based service, the client sends SOAP messages
to the service and the service responds in kind, with SOAP messages. REST-style services
are hard to characterize in a sentence or two, but with respect to pattern, these services
tend to be request/response; the same holds for SOAP-based services. For now, a REST-
style service is one that treats HTTP not only as transport infrastructure but also as a
set of guidelines for designing service requests and service responses. In a REST-style
service, HTTP itself can be seen as an API. SOAP has standards, toolkits, and bountiful
software libraries. REST has no official standards, comparatively few toolkits, and un‐
even software libraries among programming languages. Yet there is growing support
for REST-style services across programming languages; hence, it seems only a matter
of time until toolkits and libraries for REST-style services mature.

From a historical perspective, the RESTful approach to web services can be viewed as
an antidote to the creeping complexity of SOAP-based web services. SOAP-based serv‐
ices are designed to be transport-neutral; as a result, SOAP messaging may seem overly
complicated if the transport is, in fact, HTTP.

At present, the distinction
between the two flavors of web service is not sharp, because a SOAP-based service
delivered over HTTP can be seen as a special case of a REST-style service; HTTP remains
the dominant transport for SOAP-based services.

SOAP originally stood for Simple Object Access Protocol and then, by serendipity but
never officially, might have stood for Service-Oriented Architecture (SOA) Protocol.
(SOA is discussed in the section “Web Services and Service-Oriented Architecture” on
page 7.) The World Wide Web Consortium (hereafter, W3C) currently oversees SOAP,
and SOAP is officially no longer an acronym.

Web Service Miscellany
----------------------
Except in test mode, the client of either a SOAP-based or REST-style service is rarely a
web browser but, rather, usually an application without a graphical user interface. The
client may be written in any language with the appropriate support libraries. Indeed, a
major appeal of web services is language transparency: the service and its clients need
not be written in the same language. Language transparency is a key contributor to web
service interoperability—that is, the ability of web services and their consumers to in‐
teract seamlessly despite differences in programming languages, support libraries, op‐
erating systems, and hardware platforms.

There is no magic in language transparency, of course. If a web service written in Java
can have a Python or a Ruby consumer, there must be an intermediary layer that handles
the differences in data types between the service and the client languages. XML tech‐
nologies, which support structured document interchange and processing, act as one
such intermediary level. Another intermediary level is JSON (JavaScript Object Nota‐
tion). XML and JSON are both data-interchange formats, but JSON clearly has the upper
hand with data receivers written in JavaScript because a JSON document is the text
representation of a native JavaScript object. Web service clients are increasingly Java‐
Script programs embedded in HTML documents and executing in a browser; such
clients process JSON with less fuss than they do XML. Even among non-JavaScript
clients, JSON has gained in popularity; for one thing, JSON is more readable than XML
because JSON has relatively less markup.

Several features distinguish web services from other distributed software systems. Here
are three:

Open infrastructure
Web services are deployed using industry-standard, vendor-independent protocols
and languages such as HTTP, XML, and JSON, all of which are ubiquitous and well
understood. Web services can piggyback on networking, data formatting, security,
and other infrastructures already in place, which lowers entry costs and promotes
interoperability among services. Organizations that publish websites with
production-grade web servers such as Apache2, IIS, and Nginx can publish web
services with these very web servers. Firewalls and other security mechanisms that
defend websites thereby defend web services as well.

Platform and language transparency
Web services and their clients can interoperate even if written in different pro‐
gramming languages. Languages such as C, C#, Go, Java, JavaScript, Perl, Python,
Ruby, and others provide libraries, utilities, and even frameworks in support of web
services. Web services can be published and consumed on various hardware plat‐
forms and under different operating systems. Web services are an excellent way to
integrate diverse software systems while allowing the programmer to work in the
programmer’s language of choice. The web service approach to software develop‐
ment is not to rewrite but, rather, to integrate.

Modular design
Web services are meant to be modular in design so that new services can be com‐
posed out of existing ones. Imagine, for example, an inventory-tracking service
integrated with an online ordering service to compose a service that automatically
orders the appropriate products in response to inventory levels. Web services are
the small software parts out of which arbitrarily large systems can be built. A guiding
principle in web service design is to begin with very simple service operations,
essentially uncomplicated functions, and then group these operations into services,
which in turn can be orchestrated to work with other services, and so on indefinitely.

As noted earlier, web services come in different flavors: SOAP-based and REST-style.
SOAP and SOA, though related, remain distinct. The next section goes into detail about
the relationship between SOA and REST-style and SOAP-based web services.

Web Services and Service-Oriented Architecture
----------------------------------------------

Web services and SOA are related but distinct. SOA, like REST, is more an architectural
style—indeed, a mindset—than a body of precisely defined rules for the design and
implementation of distributed systems; web services are a natural, important way to
provide the services at the core of any SOA system. A fundamental idea in SOA is that
an application results from integrating network-accessible services, which are intero‐
perable because each has an interface that clearly defines the operations encapsulated
in the service. Per operation, the interface specifies the number and type of each argu‐
ment passed to the service operation together with the number and type of values re‐
turned from each service operation. The very point of a service interface is to publish
the invocation syntax of each operation encapsulated in the service. One attraction of
the SOA approach is that the ultimate building blocks of even large, complicated systems
are structurally simple components; this simplicity at the base level makes it relatively
easy to test, debug, deploy, extend, and otherwise maintain a software system.

In an SOA system, services as building block components may be characterized as
unassociated and loosely coupled. Consider, for example, two primitive services, S 1 and
S 2 , in an SOA application. The two services are unassociated in that neither S 1 nor S 2
depends on the other: S 1 is not required to use S 2 or vice versa. The services are mutually
independent but can be used together or orchestrated as parts of a larger software sys‐
tem. Following the same theme, components such as S 1 and S 2 are loosely coupled in
that neither needs to know anything about the internal structure of the other in order
for both of these services to work together as parts of a larger distributed system. A
persistent theme in the many discussions of SOA is the modularity of SOA-based
systems.

At the implementation level, a service operation is a function call: the function takes
zero or more arguments and returns zero or more values. Although functions in many
languages such as C and even Java technically return, at most, only a single value and
therefore must resort to aggregate data structures such as a lists to return multiple values,
newer languages such as Go have uncomplicated syntax for functions to return arbi‐
trarily many values including, of course, none. This fact underscores the inherent rich‐
ness and flexibility of the function as a system building block. Programmers fluent in
virtually any language are thereby knowledgeable about the syntax and semantics of
functions.

In an SOA system, a very simple service may consist of a single function. The imple‐
mentation model is thus uncomplicated and familiar to programmers, and the simplicity
of service operations promotes code reuse through the composition of new services out
of existing ones. This ground-level simplicity also enables relatively straightforward
troubleshooting because services reduce to primitive function calls. An SOA system can
be quite complicated, of course, but the complication arises from the composition and
not from the simple services into which the system ultimately decomposes.

Web services are well suited as components in an SOA system. Following best practices,
a web service should consist of operations, each of which is implemented as a stateless
function call: the call is stateless in that the return value(s) depend only on the arguments
passed to the call. In an object-oriented language such as a Java, a well-designed web
service is a class that has instance methods as service operations but no instance fields
that impact the value returned from a particular method. In practice, statelessness is
easier said than done, as the many examples in this book illustrate. In the context of
SOA, it is common to distinguish between providers and consumers of web services: the
provider furnishes the service’s functionality, and the consumer is a client that issues
requests against the service’s operations. The provider/consumer pair is commonly used
to describe web services and their clients, respectively.

Perhaps the best way to clarify SOA in the concrete is to contrast this approach to
distributed systems with a quite different approach: DOA (Distributed Object Archi‐
tecture). Web services came to fore as a reaction against the complexity of DOA systems.
The next section provides a short history of web services, with emphasis on the kinds
of software challenges that web services are meant to address.

A Very Short History of Web Services
Web services evolved from the RPC (Remote Procedure Call) mechanism in DCE (Dis‐
tributed Computing Environment), a framework for software development from the
early 1990s. DCE includes a distributed filesystem (DCE/DFS) and a Kerberos-based
authentication system. Although DCE has its origins in the Unix world, Microsoft
quickly did its own implementation known as MSRPC, which in turn served as the
infrastructure for interprocess communication in Windows. Microsoft’s COM/OLE
(Common Object Model/Object Linking and Embedding) technologies and services
were built on a DCE/RPC foundation. There is irony here. DCE designed RPC as a way
to do distributed computing (i.e., computing across distinct physical devices), and Mi‐
crosoft cleverly adapted RPC to support interprocess communication, in the form of
COM infrastructure, on a single device—a PC running Windows.

The first-generation frameworks for distributed object systems, CORBA (Common
Object Request Broker Architecture) and Microsoft’s DCOM (Distributed COM), are
anchored in the DCE/RPC procedural framework. Java RMI (Remote Method Invoca‐
tion) also derives from DCE/RPC, and the method calls in Java EE (Enterprise Edition),
specifically in Session and Entity EJBs (Enterprise Java Bean), are Java RMI calls. Java
EE (formerly J2EE) and Microsoft’s DotNet are second-generation frameworks for dis‐
tributed object systems, and these frameworks, like CORBA and DCOM before them,
trace their ancestry back to DCE/RPC. By the way, DCE/RPC is not dead. Various
popular system utilities (for instance, the Samba file and print service for Windows
clients) use DCE/RPC.

From DCE/RPC to XML-RPC
DCE/RPC has the familiar client/server architecture in which a client invokes a proce‐
dure that executes on the server. Arguments can be passed from the client to the server
and return values can be passed from the server to the client. The framework is platform-
and language- neutral in principle, although strongly tilted toward C in practice. DCE/
RPC includes utilities for generating client and server artifacts (stubs and skeletons,
respectively). DCE/RPC also provides software libraries that hide the transport details.
Of interest now is the IDL (Interface Definition Language) document that acts as the
service contract and is an input to utilities that generate artifacts in support of the DCE/
RPC calls. An IDL document can be short and to the point

/* echo.idl */
[uuid(2d6ead46-05e3-11ca-7dd1-426909beabcd), version(1.0)]
interface echo {
	const long int ECHO_SIZE = 512;

	void echo(
				[in]			handle_t h,
				[in, string]	idl_char from_client[],
				[out, string]	idl_char from_server[ECHO_SIZE]
	);
}

The IDL interface named echo , identified with a machine-generated UUID (Universally
Unique IDentifier), declares a single function with the same name, echo . The names are
arbitrary and need not be the same. The echo function expects three arguments, two of
which are in parameters (that is, inputs into the remote procedure) and one of which
is an out parameter (that is, an output from the remote procedure). The first argument,
of built-in type handle_t , is required and points to an RPC data structure. The function
echo could but does not return a value, because the echoed string is returned instead as
an out parameter. The IDL specifies the invocation syntax for the echo function, which
is the one and only operation in the service. Except for annotations in square brackets
to the left of the three echo parameters, the syntax of the IDL is essentially C syntax.
The IDL document is a precursor of the WSDL (Web Service Description Language)
document that provides a formal specification of a web service and its operations.

There is a Microsoft twist to the IDL story as well. An ActiveX control under Windows
is a DLL (Dynamic Link Library) with an embedded typelib, which in turn is a compiled
IDL file. For example, suppose that a calendar ActiveX control is plugged into a browser.
The browser can read the typelib, which contains the invocation syntax for each oper‐
ation (e.g., displaying the next month) in the control. An ActiveX control is thus a chunk
of software that embeds its own interface. This is yet another inspired local use of a
technology designed for distributed computing.

In the late 1990s, Dave Winer of UserLand Software developed XML-RPC, a technology
innovation that has as good a claim as any to mark the birth of web services. XML-RPC
is a very lightweight RPC system with support for elementary data types (basically, the
built-in C types together with a boolean and a datetime type) and a few simple com‐
mands. The original specification is about seven pages in length. The two key features
are the use of XML marshaling/unmarshaling to achieve language neutrality and reli‐
ance on HTTP (and, later, SMTP) for transport. The term marshaling refers to the
conversion of an in-memory object (for instance, an Employee object in Java) to some
other format (for instance, an XML document); unmarshaling refers to the inverse pro‐
cess of generating an in-memory object from, in this example, an XML document. The
marshal/unmarshal distinction is somewhere between close to and identical with the
serialize/deserialize distinction. My habit is to use the distinctions interchangeably. In
any case, the O’Reilly open-wire Meerkat service and the WordPress publishing plat‐
form are based on XML-RPC.

Two key differences separate XML-RPC, on the one side, from DCE/RPC and its off-
shoots, on the other side:

- XML-RPC payloads are text, whereas DCE/RPC payloads are binary. Text is rela‐
tively easy to inspect and process with standard, readily available tools such as
editors and parsers.
- XML-RPC transport uses HTTP rather than a proprietary system. To support XML-
RPC, a programming language requires only a standard HTTP library together
with libraries to generate, parse, transform, and otherwise process XML.

As an RPC technology, XML-RPC supports the request/response pattern. Here is the
XML request to invoke, on a remote machine, the Fibonacci function with an argument
of 11. This argument is passed as a 4-byte integer, as the XML start tag <i4> indicates:

<?xml version="1.0">
<methodCall>
	<methodName>fib<methodName>

	<params>
		<param>
			<value>
				<i4>11</i4>
			</value>
		</param>
	</params>
</methodCall>

The integer 11 occurs in the XML-RPC message as text. An XML-RPC library on the
receiving end needs to extract 11 as text and then convert the text into a 4-byte integer
in the receiving language such as Go or Java. Even this short example illustrates the idea
of having XML—in particular, data types expressed in XML—serve as the leveling
mechanism between two different languages involved in an XML-RPC exchange.

XML-RPC is deliberately low fuss and lightweight. SOAP, an XML dialect derived
straight from XML-RPC, is considerably heavier in weight. From inception, XML-RPC
faced competition from second-generation DOA systems such as Java EE (J2EE) and
AspNet. The next section considers the challenges inherent in DOA systems. These
challenges sustained and eventually intensified interest in lighter-weight approaches to
distributed computing—modern web services.

Distributed Object Architecture: A Java Example
-----------------------------------------------
What advantages do web services have over DOA technologies such as Java RMI? This
section addresses the question with an example. Java RMI (including the Session and
Entity EJB constructs built on Java RMI) and DotNet Remoting are examples of second-
generation distributed object systems. Consider what a Java RMI client requires in order
to invoke a method declared in a service interface such as this:

import java.util.List;
public interface BenefitsService extends java.rmi.Remote {
	public List<Benefit> getBenefits(Emp emp) throws RemoteException;
}

The interface appears deceptively simple in that it declares only the method named
getBenefits , yet the interface likewise hints at what makes a Distributed Object Ar‐
chitecture so tricky. A client against this BenefitsService requires a Java RMI stub, an
instance of a class that implements the BenefitsService interface. The stub is down‐
loaded automatically from the server to the client as part of the Java RMI setup

Once the stub setup is done, the getBenefits method is executed as a stub method;
that is, the stub acts as the client-side object making a remote method call through one
of stub’s encapsulated methods. The call thus has the following syntax:

Emp fred = new Emp();
//...
List<Benefit> benefits = rmiStub.getBenefits(fred); // rmiStub = reference

Invoking the getBenefits method requires that the byte codes for various Java classes,
standard and programmer-defined, be available on the client machine. To begin, the
client needs the class Emp , the argument type for the getBenefits method, and the class
Benefit , the member type for the List that the method getBenefits returns. Suppose
that the class Emp begins like this:

public class Emp {
	private Department
	department;
	private List<BusinessCertification> certifications;
	private List<ClientAccount>
	accounts;
	private Map<String, Contact>
	contacts;
	...
}

The standard Java types such as List and Map are already available on the client side
because the client is, by assumption, a Java application. The challenge involves the ad‐
ditional, programmer-defined types such as Department , BusinessCertification ,
ClientAccount , and Contact that are needed to support the client-side invocation of a
remotely executed method. The setup on the client side to enable a remote call such as:

Emp fred = new Emp();
// set properties, etc.
List<EmpBenefits> fredBenefits = rmiStub.getBenefits(fred);	

is significant, with lots and lots of bytes required to move from the server down to the
client just for the setup. Anything this complicated is, of course, prone to problems such
as versioning issues and outright errors in the remote method calls.

Java RMI uses proprietary marshaling/unmarshaling and proprietary transport, and
DotNet does the same. There are third-party libraries for interoperability between the
two frameworks. Yet a Java RMI service can be expected to have mostly Java clients, and
a DotNet Remoting service can be expected to have mostly DotNet clients. Web services
represent a move toward standardization, simplicity, and interoperability.

Web Services to the Rescue
--------------------------
Web services simplify matters in distributed computing. For one thing, the client and
service typically exchange XML or equivalent documents, that is, text. If needed, non-
text bytes can be exchanged instead, but the preferred payloads are text. The exchanged
text can be inspected, validated, transformed, persisted, and otherwise processed using
readily available, nonproprietary, and often free tools. Each side, client and service,
simply needs a local software library that binds language-specific types such as the Java
String to XML Schema or comparable types, in this case xsd:string . (In the qualified
name xsd:string , xsd is a namespace abbreviation and string is a local name. Of
interest here is that xsd:string is an XML type rather than a Java type.) Given these
Java/XML bindings, relatively uncomplicated library modules can convert from one to
the other—from Java to XML or from XML to Java

Processing on the client side, as on the service side, requires only locally available li‐
braries and utilities. The complexities, therefore, can be isolated at the endpoints—the
service and the client applications together with their supporting libraries—and need
not seep into the exchanged messages. Finally, web services are available over HTTP, a
nonpropriety protocol that has become standard, ubiquitous infrastructure; HTTP in
particular comes with a security extension, HTTPS, that provides multifaceted security
services.

In a web service, the requesting client and the service need not be coded in the same
language or even in the same style of language. Clients and services can be implemented
in object-oriented, procedural, functional, and other language styles. The languages on
either end may be statically typed (for instance, Java and Go) or dynamically typed (for
example, JavaScript and Ruby). The complexities of stubs and skeletons, the serializing
and deserializing of objects encoded in some proprietary format, give way to relatively
simple text-based representations of messages exchanged over standard transports such
as HTTP. The messages themselves are neutral; they have no bias toward a particular
language or even family of languages.

What Is REST?

Roy Fielding coined the acronym REST in his PhD dissertation. Chapter 5 of Fielding’s
dissertation lays out the guiding principles for what have come to be known as REST-
style or RESTful web services. Fielding has an impressive résumé. He is, among other
things, a principal author of the HTTP 1.1 specification and a cofounder of the Apache
Software Foundation.

REST and SOAP are quite different. SOAP is a messaging protocol in which the messages
are XML documents, whereas REST is a style of software architecture for distributed
hypermedia systems, or systems in which text, graphics, audio, and other media are
stored across a network and interconnected through hyperlinks. The World Wide Web
is the obvious example of such a system. As the focus here is on web services, the World
Wide Web is the distributed hypermedia system of interest. In the Web, HTTP is both
a transport protocol and a messaging system because HTTP requests and responses are
messages. The payloads of HTTP messages can be typed using the MIME (Multipurpose
Internet Mail Extension) type system. MIME has types such as text/html , applica
tion/octet-stream , and audio/mpeg3 . HTTP also provides response status codes to
inform the requester about whether a request succeeded and, if not, why. next Table lists
some common status codes.

Status 	code In English		Meaning
200 	OK	Request 		OK
303 	See Other			Redirect
400 	Bad Request			Request malformed
401 	Unauthorized		Authentication error
403 	Forbidden			Request refused
404 	Not Found			Resource not found
405 	Method Not Allowed	Method not supported
415 	Unsupported Media 	Type Content type not recognized
500 	Internal Server Error	Request processing failed

REST stands for REpresentational State Transfer, which requires clarification because
the central abstraction in REST—the resource—does not occur in the acronym. A re‐
source in the RESTful sense is something that is accessible through HTTP because this
thing has a name—URI (Uniform Resource Identifier). A URI has two subtypes: the
familiar URL, which specifies a location, and the URN, which is a symbolic name but
not a location. URIs are uniform because they must be structured in a certain way; there
is a syntax for URIs. In summary, a URI is a standardized name for a resource and, in
this sense, a URI acts as noun.

In practical terms, a resource is a web-accessible, informational item that may have
hyperlinks to it. Hyperlinks use URIs to do the linking. Examples of resources are plen‐
tiful but likewise misleading in suggesting that resources must have something in com‐
mon other than identifiability through URIs. The gross national product of Lithuania
is a resource, as is the Modern Jazz Quartet. Ernie Banks’ baseball accomplishments
count as a resource, as does the maximum flow algorithm. The concept of a resource is
remarkably broad but, at the same time, impressively simple and precise.

As web-based informational items, resources are pointless unless they have at least one
representation. In the Web, representations are MIME typed. The most common type
of resource representation is probably still text/html , but nowadays resources tend to
have multiple representations. For example, there are various interlinked HTML pages
that represent the Modern Jazz Quartet but there are also audio and audiovisual repre‐
sentations of this resource.

Resources have state. Ernie Banks’ baseball accomplishments changed during his career
with the dismal Chicago Cubs from 1953 through 1971 and culminated in his 1977
induction into the Baseball Hall of Fame. A useful representation must capture a re‐
source’s state. For example, the current HTML pages on Ernie at the Baseball Reference
website need to represent all of his major league accomplishments, from his rookie year
in 1953 through his induction into the Hall of Fame.

A RESTful request targets a resource, but the resource itself typically is created on the
service machine and remains there. A resource may be persisted in a data store such as
a database system. Some mix of humans and applications may maintain the state of the
resource. In the usual case of web service access to a resource, the requester receives a
representation of the resource if the request succeeds. It is the representation that trans‐
fers from the service machine to the requester machine. In a REST-style web service, a
client does two things in an HTTP request:

- Names the targeted resource by giving its URI, typically as part of a URL.
- Specifies a verb (HTTP method), which indicates what the client wishes to do; for
example, read an existing resource, create a new resource from scratch, edit an
existing resource, or delete an existing resource.

One of the basic cases is a read request. If a read request succeeds, a typed representation
(for instance, text/html ) of the resource is transferred from the server that hosts and
maintains the resource to the client that issues the request. The client is an arbitrary
application written in some language with support for REST-style requests. The repre‐
sentation returned from the service is a good one only if it captures the resource’s state
in some appropriate way.

In summary, RESTful web services involve not just resources to represent but also client-
invoked operations on such resources. At the core of the RESTful approach is the insight
that HTTP, despite the occurrence of Transport in its name, acts as an API and not
simply as a transport protocol. HTTP has its well-known verbs, officially known as
methods. Table 1-2 lists the HTTP verbs that correspond to the CRUD (Create, Read,
Update, Delete) operations so familiar throughout computing.

HTTP verbs and their CRUD operations
HTTP verb 	CRUD operation
POST 		Create
GET 		Read
PUT 		Update
DELETE 		Delete

Although HTTP is not case sensitive, the HTTP verbs are traditionally written in up‐
percase. There are additional verbs. For example, the verb HEAD is a variation on GET
that requests only the HTTP headers that would be sent to fulfill a GET request.

HTTP also has standard response codes such as 404 to signal that the requested resource
could not be found and 200 to signal that the request was handled successfully. In short,
HTTP provides request verbs and MIME types for client requests and status codes (and
MIME types) for service responses

Modern browsers generate only GET and POST requests. If a user enters a URL into
the browser’s input window, the browser generates a GET request. A browser ordinarily
generates a POST request for an HTML form with a submit button. It goes against the
spirit of REST to treat GET and POST interchangeably. In Java, for example, an
HttpServlet instance has callback methods such as doGet and doPost that handle GET
and POST requests, respectively. Each callback has the same parameter types: the
HttpServletRequest type (the key/value pairs from the request) and the type HttpServ
letResponse (effectively a channel to communicate back to the requester). It is not
unknown for a programmer to have the two callbacks execute the same code (for in‐
stance, by having one invoke the other), thereby conflating the original HTTP distinc‐
tion between read and create. A key guiding principle of the RESTful style is to respect
the original meanings of the HTTP verbs. In particular, any GET request should be side-
effect free (idempotent) because a GET is a read rather than a create, update, or delete
operation. A GET as a read with no side effects is called a safe GET.

The REST approach does not imply that either resources or the processing needed to
generate adequate representations of them are simple. A REST-style web service might
be every bit as subtle and complicated, in its functionality, as a SOAP-based service or
a DOA application. The RESTful approach tries to simplify a service’s implementation
by taking what HTTP and the MIME type system already offer: built-in CRUD opera‐
tions, uniformly identifiable resources, typed representations that can capture a re‐
source’s state, and status codes to summarize the outcome of a request. REST as a design
philosophy tries to isolate application complexity at the endpoints—that is, at the client
and at the service. A service may require lots of logic and computation to maintain
resources and to generate adequate representation of resources, such as large and subtly
formatted XML documents, and a client may require significant XML processing to
extract the desired information from the XML representations transferred from the
service to the client. Yet the RESTful approach keeps the complexity out of the transport
level, as a resource representation is transferred to the client as the body of an HTTP
response message. For the record, RESTful web services are Turing complete; that is,
these services are equal in power to any computational system, including a system that
consists of SOAP-based web services or DOA stubs and skeletons.

Verbs and Opaque Nouns
----------------------


In HTTP a URI is meant to be opaque, which means that the URI:

http://bedrock/citizens/fred

has no inherent connection to the URI:

http://bedrock/citizens

although Fred happens to be a citizen of Bedrock. These are simply two different, in‐
dependent identifiers. Of course, a good URI designer will come up with URIs that are
suggestive about what they are meant to identify. The point is that URIs have no intrinsic
hierarchical structure. URIs can and should be interpreted, but these interpretations are
imposed on URIs, not inherent in them. Although URI syntax looks like the syntax used
to navigate a hierarchical filesystem, this resemblance is misleading. A URI is an opaque
identifier, a logically proper name that should denote exactly one resource.

Review of HTTP Requests and Responses
-------------------------------------
The next section has a REST-style sample service whose URL is:

http://localhost:8080/predictions/

If this URL is typed into a browser’s window, the browser generates a request similar to:

GET /predictions/ HTTP/1.1
User-Agent: Mozilla/5.0 (X11; Linux x86_64) Chrome/24.0.1312.56
Host: localhost:8080
Accept: text/html

The browser parses the entered URL into these parts, with clarifications below:

-GET /predictions/ HTTP/1.1
This is the HTTP request start line:
	>GET 				is the HTTP method (verb).
	>/predictions/ 		is the URI (resource’s name).
	>HTTP/1.1 			is the HTTP version that the requester is using.

-User-Agent: Mozilla/5.0 (X11; Linux x86_64) Chrome/24.0
Immediately after the start line come the HTTP request header elements or head‐
ers for short. Each element is a key/value pair with a colon ( : ) separating the key
on the left from the value on the right. In this element, User-Agent is the key, and
everything to the right of the colon is the value. Chrome is the browser used in this
request, and Mozilla/5.0 specifies a browser compatibility type. The User-Agent
information also includes the operating system in use, 64-bit Linux. Of interest here
is that key User-Agent captures the intended meaning: it is the application (agent)
that a user employs to make a request.

-Host: localhost:8080
In localhost:8080 , the network address of the machine that hosts the resource is
to the left of the colon; the port number, in this case 8080 , is to the right. In this
example, the network address is localhost and its dotted-decimal equivalent is
127.0.0.1. Because the network address is localhost , the web server and the re‐
questing application are on the same machine, which is convenient during devel‐
opment. In a production environment, the web server might have a network address
such as dcequip.cti.depaul.edu . Port numbers range from 0 to roughly 65000,
with port numbers from 0 through 1023 typically reserved for standard applications
such as web servers (port 80 for HTTP and port 443 for HTTPS), SMTP (email,
port 25), SSH (secure shell, port 22), and so on. For convenience, the web servers
Tomcat and Jetty use port 8080 by default, but the number can be changed (for
example, to the standard HTTP port number 80). Under HTTP 1.1, the key/value
pair, with Host as the key, is required. The other header elements are optional,
although the ones shown here are typical.

-Accept: text/html
This is the MIME type ( text ) and subtype ( html ), which the browser is ready to
accept. The application running on the web server may not honor the requested
type and respond instead with, for example, text/plain or text/xml .

In summary, the key/value pairs such as: Accept: text/html
make up the HTTP request headers. These pairs may occur in any order and only the
following pair: Host: <network address> is mandatory under HTTP 1.1.

Two newlines terminate the headers section. A GET request has no body; hence, a GET
request consists only of the start line and the headers. A POST request always has a
body, which may be empty. In a POST request, two newlines mark the end of the headers.

Because a GET request has no body, such a request often includes, in the URI, a query
string that consists of key/value pairs. For example, this GET request:

http://.../products?id=27&category=boots

includes a query string with two key/value pairs: id is the first key and 27 is the value;
category is the second key and boots is the value. The query string thus provides a way
for a bodyless GET request to include information within the request. The query string
data is encapsulated in the HTTP request headers. POST requests always have a body,
which is usually nonempty. The body of a POST request holds key/value pairs as well.

If all goes well, sending an HTTP request to the URL: http://localhost:8080/predictions/
leads to an HTTP response, which is similar to:

HTTP/1.1 200 OK
Server: Apache-Coyote/1.1
Set-Cookie: JSESSIONID=35B1E3AA21EB7242FD2FC50044D2166A; Path=/predictions/;
Content-Type: text/html;charset=ISO-8859-1
Transfer-Encoding: chunked

<?xml version="1.0" encoding="UTF-8"?>
<java version="1.7.0" class="java.beans.XMLDecoder">
	<array class="predictions.Prediction" length="32">
		<void index="0">
			<object class="predictions.Prediction">
				<void property="what">
					<string>
						Managed holistic contingency will grow killer action-items.
					</string>
				</void>
				
				<void property="who">
					<string>
						Cornelius Tillman
					</string>
				</void>
			</object>
		</void>
		...
</java>

The start line: 
HTTP/1.1 200 OK

begins with the HTTP version in use on the server. Next comes the HTTP status code
(SC for short) as a number (200) and in English (OK). Status codes in the 200 range
signal success. Five header elements follow, including the name of the web server that
sends the response and the content type of the response. Note that the response type is
given as text/html rather than as what it actually is: text/xml . The reason is that my
code, which generates the response, does not bother to set the content type; hence, the
Apache-Coyote (that is, Tomcat) web server uses its default type of text/html . Two
newline characters again separate the headers from the HTTP body, which can be empty.
In this case, the body is an XML document that lists corporate predictions together with
their predictors.

HTTP as an API
--------------

HTTP can be viewed as an API. Among frameworks for developing websites and
RESTful web services, Rails has pioneered this view of HTTP, which deliberately blurs
the distinction between websites that deliver HTML and web services that deliver XML
or JSON. In a well-designed Rails application, a GET request for the URI /products is
equivalent to the same request for /products.html, and an HTML list of products is
returned in response. A GET request against /products.json or /products.xml would
return the same list but in JSON or XML, respectively. Rails has an often-copied idiom
for combining URIs and HTTP verbs into a RESTful route—the route that a request
takes to the code that handles the request. The Rails routing style is an elegant yet
practical use of HTTP as an API.

These verb/name pairs are terse, precise, intuitive, and uniform in style. The pairs il‐
lustrate that RESTful conventions can yield simple, clear routing expressions about
which operation should be performed on which resource. The POST and PUT verbs
are used in requests that have an HTTP body; hence, the request data is in the HTTP
message body. The GET and DELETE verbs are used in requests that have no body;
hence, the request data, if any, is sent as query string key/value pairs.

The decision about whether to be RESTful in a particular application depends, as always,
on practical matters that will come to the fore throughout this book. The current section
looked at REST from on high; it is now time to descend into details with code examples.
The next section summarizes the overview of HTTP with two Java clients. A first RESTful service follows.

A First RESTful Example... OK (pag 24)

PAGE 29 CONVERT TO XML




pag 29